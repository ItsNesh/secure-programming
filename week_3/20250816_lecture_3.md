<!-- 
Generated by LectureQ (Enhanced Comprehensive Version)
Date: 2025-08-16 06:00:17
Model: qwen3:30b
Output Mode: Comprehensive
-->

# Week 3: Lecture 3 - Secure Programming Fundamentals & Memory Management Vulnerabilities

## Overview

This lecture covers critical web application security vulnerabilities (SQL Injection, CSRF, XSS) and transitions to memory management issues in C-based programming. We'll explore how these vulnerabilities manifest, their defenses, and then dive deep into stack memory organization, function calls, buffer overflows, and exploitation techniques. The lecture emphasizes practical understanding of both defensive strategies and attack mechanisms.

---

## Web Application Security Vulnerabilities

### SQL Injection: Understanding the Threat

**The Core Problem**: When applications directly incorporate user input into database queries without proper sanitization, attackers can manipulate the query structure to execute arbitrary commands.

*Example from Transcript*:  
> "If your backend doesn't have any input sanitization... attackers can craft an input that always evaluates to true. For example: `1' OR 1=1;#`"

**How It Works**:  
- Normal SQL query: `"SELECT first_name, last_name FROM users WHERE user_id = '1'"`
- Malicious input: `"1' OR 1=1;#"`
- Resulting query becomes: `"SELECT first_name, last_name FROM users WHERE user_id = '1' OR 1=1;#'"`
- Since `1=1` is always true, the database returns all records

**Why It's Dangerous**:  
Attackers can:
- Extract all data from databases
- Modify or delete data
- Bypass authentication systems
- Execute arbitrary commands on the server (via techniques like UNION SELECT)

*Instructor Emphasis*: "This isn't just theoretical—SQL injection is consistently ranked among the top security vulnerabilities in real-world applications."

### SQL Injection Defense: Prepared Statements

**The Solution**: Separate query syntax from user input using parameterized queries.

```sql
-- Vulnerable code (unsafe)
$getid = "SELECT first_name, last_name FROM users WHERE user_id = '$id'";

-- Secure code (safe)
$sql = "SELECT first_name, last_name FROM users WHERE user_id = ?";
```

**How It Works**:  
- The `?` placeholder tells the database to treat all subsequent input as literal data
- Input is never interpreted as part of SQL syntax
- Even malicious inputs like `' OR 1=1;#` become harmless strings

*Instructor Insight*: "This isn't just a coding practice—it's industry standard for any application interacting with databases. If you're building anything that takes user input and uses it in database queries, prepared statements are non-negotiable."

---

### Cross-Site Request Forgery (CSRF)

**The Threat**: Attackers trick authenticated users into performing unwanted actions on a website they're logged into.

*Example from Transcript*:  
> "A bank account system... attacker tricks you to transfer money to their account. Since you're already logged in, the bank can't tell if it's genuine or malicious."

**How It Works**:  
1. User logs into legitimate site (e.g., online banking)
2. User visits attacker-controlled website
3. Attacker's page contains hidden form that submits a request to the bank
4. Browser automatically sends authentication cookies with the request
5. Bank processes the request as if it came from the user

*Visual Example*:  
```html
<img src="http://bank.com/transfer?amount=10000&dest=evilcorp">
```

**Why It's Dangerous**:  
- Users can unknowingly transfer money or change account settings
- Requires user to be authenticated on target site (not just logged in)

### CSRF Defenses

#### 1. Secret Validation Tokens
- Server generates unique token when page loads
- Token embedded as hidden field in forms
- Server validates token before processing requests
- *Why it works*: Attacker can't forge the token since they don't have access to the legitimate site's context

*Instructor Insight*: "This is why you'll see tokens like `<input type='hidden' value='23a3af01b'>` in web forms—these are CSRF tokens."

#### 2. Referrer Validation
- Server checks `Referer` header (which contains the URL of the page making the request)
- Only allows requests from legitimate domains
- *Limitation*: Some browsers or privacy settings disable referrer headers

*Instructor Insight*: "This is why you'll see `Referer: http://www.facebook.com/home.php` in network traffic—this header helps verify origin."

#### 3. Custom HTTP Headers (X-Requested-With)
- Server requires a specific custom header like `X-Requested-With: XMLHttpRequest`
- Browsers automatically include this for AJAX requests but not for cross-site requests
- *Why it works*: Attackers can't easily forge these headers

*Instructor Insight*: "This is the most robust defense because it's harder to bypass than token-based or referrer checks."

---

### Cross-Site Scripting (XSS)

**The Threat**: Attackers inject malicious scripts into web pages viewed by users.

*Key Distinction from CSRF*:  
> "CSRF requires you to be logged in, but XSS doesn't. With stored XSS, the malicious script is permanently embedded on a website and executes for every visitor."

**Why CSRF Defenses Don't Work Against XSS**:  
- CSRF defenses rely on authentication cookies or tokens
- XSS attacks don't require authentication—they inject code directly into content

*Instructor Insight*: "This is why all the CSRF defenses we discussed won't help against XSS. The attack vector is completely different—you're not tricking a user to make a request, you're making their browser execute malicious code."

### XSS Defenses

#### 1. Input Sanitization
- Filter or encode special characters before displaying content
- Convert `<` to `&lt;`, `>` to `&gt;`, etc.
- *Example*: `"Hello <script>alert('XSS')</script>"` becomes `"Hello &lt;script&gt;alert('XSS')&lt;/script&gt;"`

*Instructor Insight*: "This is why you'll see functions like `htmlspecialchars()` in PHP or similar encoding mechanisms—this prevents the browser from interpreting input as code."

#### 2. Content Security Policy (CSP)
- Define which sources of content are allowed to execute
- *Example policy*: `"default-src 'self'; script-src 'self' https://trusted.cdn.com"`
- Blocks unauthorized JavaScript execution

*Instructor Insight*: "This is the most robust defense because it prevents malicious scripts from executing at all, not just by sanitizing input."

---

## Memory Management Issues in C-Based Programming

### Stack Memory Fundamentals

**Memory Layout Overview**:  
```
High Address
+------------------+
|      Heap        |
+------------------+
|     Data Segment | (Global variables)
+------------------+
|    Text Segment  | (Executable code)
+------------------+
|      Stack       |
+------------------+
Low Address
```

**Key Characteristics of Stack Memory**:  
- Grows *downward* from high to low addresses
- Used for function calls, local variables, and return addresses
- Each "frame" is typically 4 bytes (32-bit systems)

*Instructor Insight*: "This downward growth can be confusing at first—imagine a stack of books where you add new books on top but the stack itself moves down as it gets taller."

---

### Stack Frame Organization

**Stack Layout Conventions**:  
- **Local variables** are stored from *higher to lower addresses* within their frame
- **Structs/arrays** store elements from *lower to higher addresses*
- **Global variables** follow the same convention as structs (low-to-high)

*Example*: For a struct with `long long`, `int`, and another `int`:
```
Address: 0x1000 | 0x1004 | 0x1008
Content:   f1     |   f2   |   f3
```

**Visual Representation**:  
```
Higher Addresses
+-----------------+
|      local var  |
|        (a)      |
+-----------------+
| struct b (f1,f2,f3) |
+-----------------+
|      local var  |
|        (c)      |
+-----------------+
Lower Addresses
```

*Instructor Insight*: "This is why it's confusing—local variables grow downward within their frame, but the stack itself grows downward overall. It's like a building where each floor has its own layout."

---

### Registers and Stack Pointers

**Key Registers**:  
| Register | Purpose                          |
|----------|----------------------------------|
| EBP      | Base Pointer (points to top of current stack frame) |
| ESP      | Stack Pointer (points to bottom of current stack frame) |
| EIP      | Instruction Pointer (points to next instruction to execute) |

**How Pointers Work**:  
- Registers store *addresses*, not values
- Example: `EBP = 0xbffff320` means "the base pointer points to address 0xbffff320"

*Instructor Insight*: "This is why we use arrows in diagrams—registers point to memory locations, but they don't contain the actual data."

---

### Function Call Process (x86)

**The Complete Sequence**:  
1. Push arguments onto stack (in reverse order)
2. Push old EIP (return instruction pointer) on stack
3. Move EIP to callee's code
4. Push old EBP (saved frame pointer) on stack
5. Move EBP to current ESP
6. Move ESP down to create space for local variables
7. Execute function body
8. Move ESP up to restore previous ESP
9. Pop saved EBP back into EBP
10. Pop saved EIP back into EIP (via `ret` instruction)
11. Remove arguments from stack

*Instructor Insight*: "This is why you'll see the sequence `push %ebp; mov %esp, %ebp; sub $4, %esp` at the start of every function—it's setting up the stack frame."

**Visual Representation**:  
```
Before Call:
[Caller Frame] [Arguments]
ESP → |  Argument #1 | 
      |  Argument #2 |
      +--------------+
EBP → | Saved EBP    |

During Call (after prologue):
[Caller Frame] [Callee Frame]
ESP → | Local Var    |
      | Local Var    |
      | Old EIP      |
      | Old EBP      |
      +--------------+
EBP → | Saved EBP    |
```

---

### Buffer Overflow Vulnerabilities

**The Core Problem**: C doesn't check array bounds, so attackers can write beyond allocated memory.

*Example from Transcript*:  
> "C has no concept of array length; it just sees a sequence of bytes. If you allow an attacker to start writing at a location and don't define when they must stop, they can overwrite other parts of memory!"

**Vulnerable Code**:  
```c
char name[20];
gets(name);  // No bounds checking!
```

*Why `gets()` is Dangerous*:  
- Reads until newline (`\n`) or end-of-file (EOF), not until buffer ends
- Can write beyond the allocated 20 bytes

**Memory Layout Example**:  
```
Higher Addresses
+------------------+
|   instrux[20]    |  // "none" stored here
+------------------+
|      name[20]    |
+------------------+
Lower Addresses
```

*Instructor Insight*: "This is why `gets()` was deprecated in C—there's no way to safely use it. Always prefer functions with explicit size limits."

---

### Stack Smashing: Exploiting Buffer Overflows

**The Attack Vector**:  
- Overflow buffer to overwrite the **Saved Frame Pointer (SFP)** and **Return Instruction Pointer (RIP)**
- When function returns, RIP points to attacker-controlled address
- Execution jumps to malicious code

*Instructor Insight*: "This is why stack smashing is so dangerous—it lets attackers take complete control of program execution."

**Attack Sequence**:  
1. Overflow buffer to overwrite SFP and RIP
2. Set RIP to point to shellcode in memory
3. When function returns, EIP jumps to shellcode

*Example Attack Input*:  
```python
# For a 20-byte name buffer:
shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80"
input = shellcode + b'A' * 12 + b'\x40\xcd\xff\xbf'
```

*Why This Works*:  
- `shellcode`: Malicious code to spawn a shell
- `b'A'*12`: Fills remaining buffer space and SFP
- `\x40\xcd\xff\xbf`: Address of shellcode (little-endian)

**Memory Layout After Attack**:  
```
Higher Addresses
+------------------+
|      RIP         | → 0xbfffcd40 (shellcode)
+------------------+
|     SFP          | → 'AAAA' (invalid address)
+------------------+
|    name[20]      |
|   shellcode + A's|
+------------------+
Lower Addresses
```

*Instructor Insight*: "This is why buffer overflows are so dangerous—they can lead to arbitrary code execution, which means attackers can do anything the program can do."

---

### Mitigating Buffer Overflows

**Solution 1: Use Safe Functions with Explicit Size Limits**

```c
// Vulnerable (no size limit):
gets(name);

// Secure (explicit buffer size):
fgets(name, sizeof(name), stdin);
```

*Instructor Insight*: "This is why `fgets()` should always replace `gets()`—it's the most basic defense against buffer overflows."

**Solution 2: Use Safe String Functions**

| Vulnerable Function | Safer Alternative |
|---------------------|-------------------|
| `strcpy`            | `strncpy`, `strlcpy` |
| `strlen`            | `strnlen`         |
| `gets`              | `fgets`           |

*Instructor Insight*: "Always check the man pages for functions—many have safer alternatives that prevent buffer overflows."

---

### Memory-Safe Code: Beyond Stack Overflows

**Heap Overflow Vulnerability**:  
```c
char *name = malloc(20);
gets(name);  // Still vulnerable!
```

*Instructor Insight*: "Heap overflows are also dangerous! The same principles apply—just different memory regions."

**Why Size Specification Matters**:  
- `sizeof(name)` returns size of the variable (not pointer)
- Works for arrays but not pointers

```c
char name[20];
fgets(name, sizeof(name), stdin);  // Correct usage
```

---

## Summary & Key Takeaways

### Critical Vulnerabilities Overview
| Vulnerability | Core Problem | Primary Defense |
|---------------|--------------|----------------|
| SQL Injection | Unsanitized user input in queries | Prepared statements |
| CSRF | Tricking authenticated users into actions | Secret tokens, referrer checks |
| XSS | Injecting malicious scripts into content | Input sanitization, CSP |
| Buffer Overflow | Writing beyond allocated memory | Safe functions with size limits |

### Key Principles for Secure Coding
1. **Never trust user input**—always sanitize or validate it.
2. **Use safe alternatives to dangerous functions** (e.g., `fgets` instead of `gets`).
3. **Separate data from code** in all interactions (especially database queries).
4. **Always specify buffer sizes** when copying strings.

### Memory Management Fundamentals
- Stack grows *downward* from high to low addresses.
- Function calls require saving EIP, EBP, and arguments on the stack.
- Buffer overflows exploit lack of bounds checking in C.
- Overwriting RIP allows attackers to redirect execution flow.

---

## Study Questions

1. Explain why SQL injection is possible with `$_GET['id']` but not with prepared statements.
2. How would you modify a vulnerable PHP script using `mysql_query()` to use prepared statements?
3. Why don't CSRF defenses work against XSS attacks? Provide specific examples of each vulnerability type.
4. Describe the memory layout for this struct:
   ```c
   struct example {
       int x;
       char y[5];
       double z;
   };
   ```
5. What happens during a function call in terms of EBP, ESP, and EIP registers?
6. Why is `gets()` dangerous compared to `fgets()`? Provide an example.
7. How does the "stack smashing" attack work at the memory level?
8. Explain why buffer overflows can lead to arbitrary code execution.
9. What are the three main steps in a function call (from assembly perspective)?
10. Why is it important to use `sizeof(name)` instead of hard-coded values when using safe string functions?

---

## Practical Exercise

**Scenario**: You're developing an authentication system where users enter their username and password.

**Task**: 
1. Write the secure code for a login function that uses prepared statements.
2. Explain how you would defend against XSS attacks in this scenario.
3. Describe what happens if an attacker submits 50 characters as a username (assuming buffer size is 20 bytes).
4. How could you prevent the buffer overflow attack from happening?

*Hint*: Consider both input validation and using safe string functions for all user inputs.

---

## Additional Resources

- **CWE Top 25**: [https://cwe.mitre.org/top25/](https://cwe.mitre.org/top25/)
- **OWASP Top 10**: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)
- **man pages for safe string functions** (e.g., `man fgets`, `man strlcpy`)
- **Rangeforce modules on memory safety and buffer overflows**


*Instructor Final Note*: "Remember—secure programming isn't about avoiding all vulnerabilities; it's about understanding the common ones, implementing defenses against them, and recognizing when you might be vulnerable."
