<!-- 
Generated by LectureQ (Enhanced Comprehensive Version)
Date: 2025-11-11 13:25:16
Model: qwen3:30b
Output Mode: Comprehensive
-->

# Week 12: Lecture 12 - Secure Programming Final Review

## Overview
This lecture serves as a comprehensive review of all major topics covered throughout the Secure Programming course, with specific focus on examinable content for the final exam. The instructor emphasizes key concepts, clarifies common misconceptions, and provides guidance on what will be tested. The lecture covers security principles, threat modeling, common vulnerabilities, memory-related attacks, mitigation techniques, and security testing approaches. The final exam will be closed-book with a 2-hour duration worth 40 marks, and students may bring one A4 double-sided page of handwritten or printed notes.

---

## Threat Modeling & Security Design Principles

### STRIDE Threat Modeling
STRIDE is a framework for identifying security threats, where each letter represents a different threat category:

- **S**poofing: Impersonating another user or system
- **T**ampering: Unauthorized modification of data
- **R**epudiation: Denying actions after they've occurred
- **I**nformation Disclosure: Unauthorized access to sensitive data
- **D**enial of Service: Preventing legitimate users from accessing resources
- **E**levation of Privilege: Gaining higher access than intended

*Instructor Emphasis*: "STRIDE is a foundational framework for threat modeling. You'll need to map scenarios to STRIDE categories and propose mitigations."

### Key Insight from Transcript
> "When we use STRIDE for threat modeling, we're approaching security from the perspective of defenders or developers. We identify critical assets, entry points into the system, and how to tighten those entry points to prevent attacks."

*Instructor Emphasis*: "Don't confuse STRIDE with attack trees. STRIDE is a threat modeling framework from the defender's perspective, while attack trees model how attackers might penetrate your system."

*Student Question*: "How would you map a scenario to STRIDE?"

*Instructor Response*: "For example, if an attacker can modify user data in a database without authorization, that's a **Tampering** threat. The mitigation would be to encrypt the data at rest and use parameterized queries to prevent SQL injection."

---

### Attack Trees
Attack trees model potential attack paths using a tree structure where:
- **Root node** represents the attacker's goal
- **Child nodes** represent sub-goals or methods to achieve the goal
- **Leaf nodes** represent specific attack techniques

*Instructor Emphasis*: "Attack trees are different from STRIDE because they approach security from the attacker's perspective, showing how an attacker might penetrate your system."

*Practical Example*: "Imagine a scenario where an attacker wants to access a password file. The root node would be 'Access password file.' Child nodes might include 'Exploit a buffer overflow' or 'Bypass authentication.' Leaf nodes could be 'Use a specific buffer overflow technique' or 'Guess a weak password.'"

---

### Security by Design & Kerckhoffs' Principle
**Security by Design** means considering security from the very beginning of development, not as an afterthought.

**Kerckhoffs' Principle** states: *"A cryptographic system should remain secure even if everything about the system, except the key, is public knowledge."*

*Instructor Emphasis*: "This is critical to remember! When designing systems, assume attackers know all your algorithms and technologies. The only secret should be the key. This is why we use standard, well-vetted cryptographic algorithms rather than custom ones."

*Key Insight*: "Kerckhoffs' Principle is often misunderstood. It doesn't mean you should keep your security methods secret, but that your system should be secure even if the attacker knows everything about it except the secret key."

---

### CIA Triad & Asset Identification
When designing secure systems, you must identify your **assets** and understand the **CIA triad** (Confidentiality, Integrity, Availability) impacts:

| Asset Type | Examples | CIA Impact |
|------------|----------|------------|
| People | Employees, customers | Confidentiality (privacy), Integrity (trust) |
| Data | User information, financial records | Confidentiality, Integrity |
| Technology | Servers, databases, devices | Availability, Integrity |
| Processes | Business logic, workflows | Integrity, Availability |

*Instructor Emphasis*: "When designing for security, you need to know what assets you have and what happens if they're compromised. For example, if a database containing user passwords is compromised, that's a breach of **Confidentiality** and **Integrity**."

---

## OWASP Top 10 & Common Web Vulnerabilities

### OWASP Top 10
The OWASP Top 10 is a standard awareness document for web application security risks. It's not just about vulnerabilities but **risks** (which combine exploitability and impact).

*Key Insight from Transcript*: "OWASP is about risk, not just vulnerabilities or impacts. Risk = Exploitability Ã— Impact."

*Instructor Emphasis*: "Don't confuse authentication and authorization. **Authentication** verifies identity (e.g., password check), while **authorization** determines what a user can do after authentication (e.g., access control)."

### SQL Injection
SQL injection occurs when attackers inject malicious SQL code into user input fields.

*How it works*: Attackers input SQL statements that manipulate the query logic. For example:
- `username = ' OR '1'='1` (always evaluates to true)
- `username = ' -- ` (comments out the rest of the query)

*Instructor Emphasis*: "SQL injection is dangerous because it can allow attackers to bypass authentication, access all data, or even execute system commands."

*Mitigation*: **Parameterized queries** (prepared statements) separate user input from query syntax. For example:
```python
# Vulnerable code (SQL injection risk)
query = "SELECT * FROM users WHERE username = '" + username + "'"

# Secure code (parameterized)
query = "SELECT * FROM users WHERE username = ?"
cursor.execute(query, (username,))
```

*Practical Example*: "If an attacker enters `admin' --` in a username field, the query becomes `SELECT * FROM users WHERE username = 'admin' --'`, which effectively comments out the rest of the query, allowing the attacker to log in as admin without a password."

---

### Cross-Site Scripting (XSS)
XSS occurs when attackers inject malicious scripts into web pages viewed by users.

**Types of XSS**:
1. **Reflected (Non-Persistent)**: Malicious script is embedded in a URL and executed when the user clicks the link. The script isn't stored on the server.
2. **Stored (Persistent)**: Malicious script is stored on the server (e.g., in a database) and executed whenever the page is loaded.

*Instructor Emphasis*: "Reflected XSS doesn't require user interaction beyond clicking a link, while stored XSS is more dangerous because it affects all users who view the compromised page."

*Student Question*: "What's the consequence of non-persistent XSS?"

*Instructor Response*: "Essentially, it's still executing malicious code, but the code isn't stored in the database. It's usually embedded in a malicious website or ad that, when clicked, executes the script. For example, an attacker might place an ad on a legitimate site that, when clicked, redirects to a malicious site."

*Mitigation*: **Input sanitization** (removing or escaping dangerous characters) or **Content Security Policy (CSP)** headers.

*Key Insight*: "Sanitizing inputs is the primary defense against XSS. Most modern web frameworks have built-in functions for this."

---

### Cross-Site Request Forgery (CSRF)
CSRF occurs when an attacker tricks a user's browser into making unauthorized requests to a web application.

*How it works*: The attacker creates a malicious website that automatically sends a request to a target site where the user is authenticated.

*Instructor Emphasis*: "CSRF requires the user to be authenticated to the target site. The attacker exploits the user's existing session."

*Key Difference*: "XSS executes malicious code on the user's browser, while CSRF makes the user's browser make requests to a target site without their knowledge."

*Mitigation*: **Anti-CSRF tokens** (unique tokens embedded in forms that must be submitted with the request).

*Practical Example*: "If a user is logged into their bank account and visits a malicious site, the site could automatically send a request to transfer money to the attacker's account because the user's browser automatically sends the authentication cookies."

---

### Command Injection
Command injection occurs when attackers inject operating system commands into user input.

*How it works*: Similar to SQL injection, but for system commands. For example:
- `ping 127.0.0.1; ls` (executes `ls` command after ping)

*Instructor Emphasis*: "Command injection is dangerous because it can allow attackers to execute arbitrary commands on the server."

*Mitigation*: **Input validation** and **avoiding direct command execution** with user input.

---

## Memory Vulnerabilities & Mitigations

### x86 Architecture & Stack Registers
Understanding memory layout is crucial for understanding memory vulnerabilities.

| Register | Purpose | Location in Stack |
|----------|---------|-------------------|
| **EIP** (Instruction Pointer) | Points to the next instruction to execute | Top of stack (return address) |
| **EBP** (Base Pointer) | Points to the beginning of the current stack frame | Middle of stack |
| **ESP** (Stack Pointer) | Points to the top of the stack (last frame added) | Bottom of stack |

*Instructor Emphasis*: "You don't need to know assembly code for the exam, but you must understand these registers because they're critical to understanding buffer overflows."

---

### Buffer Overflows
Buffer overflows occur when more data is written to a buffer than it can hold, potentially overwriting adjacent memory.

**Types of Buffer Overflows**:
1. **Stack Buffer Overflow**: Overwriting the return address on the stack
2. **Heap Buffer Overflow**: Overwriting memory allocated on the heap

*Instructor Emphasis*: "For stack overflows, attackers typically overwrite the return address (EIP) to redirect execution to malicious code."

*Key Insight*: "The key to exploiting a buffer overflow is understanding the stack layout and how to overwrite the return address."

---

### Format String Vulnerabilities
Format string vulnerabilities occur when a program uses user input as a format string without proper validation.

*How it works*: Forgetting to include sufficient format parameters in functions like `printf()`.

*Example*:
```c
char buffer[100];
scanf("%s", buffer);
printf(buffer);  // Vulnerable: buffer content is used as format string
```

*Instructor Emphasis*: "This is dangerous because attackers can use format specifiers like `%x` or `%s` to read or write arbitrary memory locations."

*Mitigation*: Always include sufficient format parameters (e.g., `printf("%s", buffer);`).

---

### Off-by-One Vulnerabilities
Off-by-one vulnerabilities occur when a buffer is written one byte beyond its allocated size.

*How it works*: Similar to buffer overflows but only overwriting the first byte of the stack frame pointer.

*Instructor Emphasis*: "Off-by-one is a special case of stack smashing where you only overwrite the first byte of the frame pointer, but the concept is the same."

---

### Integer Overflows
Integer overflows occur when an integer value exceeds its maximum capacity and wraps around to the minimum value.

*How it works*: For example, in a 32-bit signed integer, `2147483647 + 1 = -2147483648`.

*Instructor Emphasis*: "Integer overflows can be subtle and hard to detect. For example, Google once had a security flaw due to an integer overflow."

*Mitigation*: Use larger integer types (e.g., `long` instead of `int`) or check for overflow conditions.

*Key Insight*: "Integer overflows are dangerous because they can lead to buffer overflows or other memory corruption."

---

### Memory Vulnerability Mitigations

| Mitigation | How It Works | Bypass Methods |
|------------|--------------|----------------|
| **NX Bit (Non-Executable Stack)** | Makes stack memory non-executable | Return-to-libc, Return-Oriented Programming (ROP) |
| **Stack Canaries** | Random value placed before stack frame; if changed, program terminates | Brute force guessing (harder on 64-bit systems) |
| **ASLR (Address Space Layout Randomization)** | Randomizes memory layout to make exploitation harder | Brute force, information leaks |

*Instructor Emphasis*: "NX bit prevents direct execution of attacker code on the stack, but attackers can bypass it using Return-to-libc or ROP."

*Key Insight*: "Return-to-libc is when attackers redirect execution to existing library functions (like `system()`) instead of executing their own code. ROP is more advanced, chaining together small code snippets (gadgets) from existing memory."

*Practical Example*: "With NX bit enabled, attackers can't execute shellcode on the stack. Instead, they use ROP to chain together existing functions like `system()` and `exit()` to achieve their goal."

---

## Race Conditions & Side Channel Attacks

### Race Conditions
Race conditions occur when multiple processes access shared resources in an unexpected order.

*Instructor Emphasis*: "Race conditions only happen in multi-threaded or multi-processing applications. They won't occur in single-threaded code."

*Key Types*:
1. **TOCTOU (Time of Check to Time of Use)**: Exploiting the gap between checking a resource and using it.
2. **Dirty COW (Copy-on-Write)**: Exploiting the copy-on-write mechanism in operating systems.

*TOCTOU Example*:
```c
if (access("/etc/passwd", R_OK) == 0) {  // Check
    FILE *f = fopen("/etc/passwd", "r");  // Use
    // ...
}
```

*Instructor Emphasis*: "Attackers can replace the file with a symlink during the gap between check and use, allowing them to access privileged files."

*Mitigation*: "Use atomic operations or disable symbolic links for sensitive files."

*Dirty COW Explanation*: "Dirty COW exploits the copy-on-write mechanism. When two processes access the same file, they share memory. When one process writes, a copy is made. Attackers can trick the system into writing to the original file by using `madvise(MADV_DONTNEED)`."

*Instructor Emphasis*: "Dirty COW is complex to mitigate and involves deep OS knowledge, so it's unlikely to be tested."

---

### Side Channel Attacks
Side channel attacks exploit information from unintended channels (not the primary security mechanism).

*Instructor Emphasis*: "Side channel attacks target the microarchitecture (hardware design), not the software. Even a perfectly written program can be vulnerable."

**Three Main Types**:

1. **Flush & Reload**: Exploits cache timing to infer sensitive information.
2. **Meltdown**: Exploits out-of-order execution to read kernel memory.
3. **Spectre**: Exploits branch prediction to read sensitive information.

*Key Insight*: "These attacks are dangerous because they target hardware design, not software vulnerabilities."

*Meltdown Example*: "An attacker requests kernel data before checking access rights. The kernel reads the data into cache before denying access. The attacker then uses flush & reload to read the cache and obtain the sensitive data."

*Spectre Example*: "An attacker exploits branch prediction to execute code that shouldn't run, then uses timing to infer sensitive information."

*Instructor Emphasis*: "For the exam, focus on understanding the principles, not the technical details of how to exploit them."

---

## Security Testing & Code Review

### Code Review Approaches
1. **Manual Code Review**: Human review of code without tools.
2. **Static Analysis (SAST)**: Analyzing code without executing it.
3. **Dynamic Analysis (DAST)**: Analyzing code while executing it.

*Instructor Emphasis*: "SAST is like a white box test (you have full code access), while DAST is like a black box test (you only know inputs and outputs)."

---

### Manual Code Review Checklist
- **Input Handling**: Check all user input for validation and sanitization.
- **Authentication**: Verify that authentication mechanisms are secure.
- **Authorization**: Ensure users can't perform actions beyond their privileges.
- **Configuration**: Check third-party libraries and frameworks for known vulnerabilities.
- **Error Handling**: Ensure sensitive information isn't leaked in error messages.

*Instructor Emphasis*: "Manual code review is time-consuming but can detect subtle bugs that automated tools miss, especially business logic flaws."

*Key Insight*: "The main advantage of manual review is detecting tricky bugs that automated tools can't find, but it's dependent on the reviewer's expertise."

---

### Static Analysis (SAST)
SAST tools analyze code without executing it. Three main approaches:

1. **Pattern Matching**: Looking for known unsafe patterns (e.g., `=` instead of `==`).
2. **Taint Analysis**: Tracking data flow from sources (user input) to sinks (execution points).
3. **Symbolic Execution**: Exploring all possible code paths based on inputs.

*Instructor Emphasis*: "SAST tools can't be perfect because they'd need to solve the halting problem, which is impossible."

*Key Insight*: "SAST has better coverage but can produce false positives, while DAST is better at confirming exploits but has worse coverage."

---

### Dynamic Analysis (DAST)
DAST tools test running applications. Includes:
- **Unit Testing**: Testing individual functions.
- **Integration Testing**: Testing how components work together.
- **Regression Testing**: Ensuring existing features still work after changes.

*Instructor Emphasis*: "DAST is great for confirming exploits (if an input crashes the app, it's definitely a vulnerability), but it's hard to generate effective test cases."

---

### Fuzzing
Fuzzing automatically generates test inputs to find vulnerabilities.

**Types of Fuzzing**:
1. **Mutation-Based**: Start with a valid input and mutate it (e.g., add characters to a string).
2. **Generation-Based**: Generate inputs based on a specification (e.g., protocol structure).
3. **Coverage-Guided**: Focus on inputs that explore new code paths.

*Instructor Emphasis*: "Coverage-guided fuzzing is smarter because it focuses on inputs that trigger new code paths, which is where vulnerabilities often hide."

*Key Insight*: "Fuzzing is particularly effective for finding memory vulnerabilities like buffer overflows."

---

## Malware & Security Logging

### Malware Types
- **Viruses**: Require user action to propagate (e.g., opening an infected file).
- **Worms**: Propagate automatically without user action.
- **Rootkits**: Hide within the operating system to avoid detection.

*Instructor Emphasis*: "The key difference is that viruses need user action to spread, while worms don't."

---

### Logging & Auditing
- **Logging**: Recording security-relevant events (e.g., login attempts, file access).
- **Auditing**: Reviewing logs to detect security incidents.

*Instructor Emphasis*: "Logs should never contain sensitive information (like passwords) because they could be leaked."

---

### Security Monitoring Tools
- **IDS (Intrusion Detection System)**: Monitors network traffic for suspicious activity.
- **IPS (Intrusion Prevention System)**: Monitors and blocks suspicious activity in real-time.
- **SIEM (Security Information and Event Management)**: Aggregates and analyzes security logs from multiple sources.

*Instructor Emphasis*: "IDS is like a security guard watching for trouble, while IPS is like a security guard who can stop trouble."

---

## Summary & Key Takeaways

### Final Exam Format
- **Closed book** (no slides or laptops)
- **2 hours**, worth **40 marks**
- **Allowed**: 1 A4 double-sided page of notes (handwritten or printed)
- **Question types**: Multiple choice, fill-in-the-blanks, short answer (code review or scenario analysis)

### Critical Concepts to Review
1. **STRIDE threat modeling** and how to map scenarios to it
2. **OWASP Top 10** and the difference between authentication vs. authorization
3. **SQL injection** and **XSS** (reflected vs. stored) with mitigation techniques
4. **Memory vulnerabilities** (buffer overflows, format strings, integer overflows) and their mitigations
5. **Kerckhoffs' Principle** for security design
6. **Race conditions** (TOCTOU, Dirty COW) and **side channel attacks** (flush & reload, Meltdown, Spectre)
7. **Code review approaches** (manual, static, dynamic) and **fuzzing** techniques
8. **Malware types** (viruses, worms, rootkits) and **security monitoring tools** (IDS, IPS, SIEM)

### Key Exam Tips
- **Focus on principles**, not implementation details
- **Understand the "why"** behind each concept
- **Be able to differentiate** similar concepts (e.g., XSS vs. CSRF)
- **Know the key mitigations** for common vulnerabilities
- **Remember the exam rules**: Only 1 A4 page of notes allowed

---

## Study Questions

1. Explain Kerckhoffs' Principle and why it's important for secure system design.
2. Map a scenario where an attacker can modify user data without authorization to the STRIDE framework. Propose a mitigation.
3. What's the difference between reflected XSS and stored XSS? Provide an example of each.
4. How does SQL injection work, and what's the primary mitigation technique?
5. Describe how a buffer overflow attack works, focusing on the role of the EIP register.
6. Explain the difference between NX bit and stack canaries as mitigations for buffer overflows.
7. What is the principle behind Return-to-libc attacks, and how do they bypass NX bit?
8. How does TOCTOU work, and what's a common mitigation technique?
9. What is the key difference between a virus and a worm in terms of propagation?
10. Explain the difference between SAST and DAST, and when each is most useful.
11. What is a side channel attack, and why are they particularly dangerous?
12. How does ASLR work, and what are its limitations?
13. Why is input sanitization important for preventing XSS attacks?
14. What is the purpose of a stack canary, and how does it work?
15. How does a format string vulnerability differ from a buffer overflow?
16. Explain the difference between authentication and authorization, and provide an example of a risk related to each.
17. What is the main limitation of static analysis tools, and why can't they be perfect?
18. How does coverage-guided fuzzing differ from mutation-based fuzzing?
19. What is the key insight behind Meltdown and Spectre attacks?
20. Why is it important to avoid logging sensitive information like passwords?