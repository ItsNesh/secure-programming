<!-- 
Generated by LectureQ (Enhanced Comprehensive Version)
Date: 2025-11-12 00:50:02
Model: qwen3:30b
Output Mode: Comprehensive
-->

# Week 10: Lecture 10 - Dynamic Analysis, Malware, and Logging

## Overview
This lecture covers three major security topics: dynamic analysis techniques (particularly fuzzing), malware types and propagation strategies, and logging and auditing practices. We'll explore how to integrate dynamic analysis into the software development lifecycle, understand the differences between various malware types (viruses, worms, rootkits), and learn best practices for effective logging and auditing. The lecture also examines polymorphic and metamorphic code as evasion techniques used by malware authors, and how security tools attempt to detect these threats.

---

## Dynamic Analysis Fundamentals

### Understanding Dynamic Analysis
Dynamic analysis involves testing software while it's running, observing its behavior to identify vulnerabilities. Unlike static analysis (which examines code without execution), dynamic analysis treats the system as a **black box**—we only know inputs and outputs, not the internal code structure.

> "Dynamic analysis usually assumes that the system we're testing is a black box, so we only know the inputs and outputs of the systems, unlike static analysis where we have access to the entire code base and know exactly like the data flows, the control flows in the source code."

*Instructor Emphasis*: "Dynamic analysis is particularly useful when you can't come up with good test cases yourself—it's a way to explore code paths you might not have considered."

*Student Question*: "If you use some tools, then it's considered static analysis. But I didn't try to run and only read that code, then it can be considered as manual code review."

*Instructor Response*: "If you read code without executing it, that's manual code review. Static analysis requires scanning code without execution, while dynamic analysis requires running the code to observe behavior."

### Fuzzing: An Advanced Dynamic Testing Technique

Fuzzing automatically generates inputs to find vulnerabilities by testing how software handles unexpected or malformed data. It's particularly useful when creating test cases manually is challenging.

#### Three Key Fuzzing Techniques

| Technique | Input Source | Validity of Inputs | Learning from Execution | Complexity | Typical Target Formats |
|-----------|--------------|-------------------|------------------------|------------|------------------------|
| **Mutation-based** | Existing files | Often low | No | Simple | Binary, text |
| **Generation-based** | Input specification | High (if spec is good) | No | Complex | Structured protocols |
| **Coverage-guided** | Any (mutation/generation) | Medium to High (guided) | Yes | Moderate | Any executable program |

*Instructor Insight*: "Mutation-based is the simplest because you just need to do some random operations, mutations. However, for generation-based and coverage-guided, it will be more complex. Particularly for generation-based because you need to understand the specification you want to test."

#### Practical Application of Fuzzing

**Mutation-based Fuzzing**  
Start with an initial corpus (e.g., a random string or empty string for a string-input system), then apply random modifications to create new test inputs. This is simple but may not explore new code paths effectively.

**Generation-based Fuzzing**  
Use a well-defined specification or template to generate inputs. For example, if testing a protocol, start with the known structure and generate random values within that structure. This is more effective when you have a clear specification.

**Coverage-guided Fuzzing**  
Maximize the number of code paths covered by inputs. It learns from execution—previous inputs that explored new paths are prioritized for future testing. This is particularly valuable for finding vulnerabilities in hard-to-reach code paths.

> "Coverage-guided fuzzing is designed to explore as many code paths as possible, including those that are vulnerable. It checks whether previous inputs have managed to explore new paths, and if so, prioritizes those inputs for the next round of fuzzing."

*Instructor Emphasis*: "If you just design your own test cases, there are chances you won't be able to come up with all the special test cases, especially if you're not very familiar with the code base or you're not an experienced tester."

### Integrating Dynamic Analysis into the SDLC

Dynamic analysis requires code to be complete and executable, which means it's typically performed later in the development lifecycle compared to static analysis.

#### Testing Types in the SDLC

1. **Unit Tests**: Verify individual components work as expected in isolation.
   - *Goal*: Cover all code, including error handling.
   - *Why it matters*: "Many exploitable bugs would be eliminated with basic unit tests."

2. **Regression Tests**: Ensure existing functionality still works after new code is added.
   - *Why it matters*: "If you don't run regression tests, attackers will run them for you!"

3. **Integration Tests**: Verify modules work together as expected.
   - *Why it matters*: "Test the entire system as a whole to make sure everything works with new features included."

> "Dynamic analysis usually takes longer than static analysis because it requires waiting for the program to execute and complete to figure out whether there's a bug at runtime."

*Instructor Insight*: "Dynamic analysis provides clear evidence that a code has a vulnerability because if you can crash the application, you know there's a bug there. For static analysis, it can produce many false positives."

---

## SAST vs DAST: A Critical Comparison

### Key Differences

| Feature | SAST (Static Analysis) | DAST (Dynamic Analysis) |
|---------|------------------------|-------------------------|
| **Coverage** | High (may produce many warnings) | Lower (may miss some vulnerabilities) |
| **SDLC Integration** | Can be done early (before code is committed) | Requires completed code |
| **Ease of Setup** | Easier | More difficult |
| **Code Visibility** | Full access to source code | Black box (no source code access) |
| **Remediation Advice** | Often includes specific code fixes | May require more investigation |
| **False Positives** | Higher | Lower (if you can reproduce the issue) |
| **Verify Exploitability** | Cannot verify if vulnerability is exploitable | Can verify exploitability |

> "Dynamic analysis can reduce the false positive rate because if you can crash the application, it confirms there's a bug there. However, the trade-off is that you may not be able to find all test cases that trigger vulnerabilities."

*Instructor Emphasis*: "Dynamic analysis is language-agnostic because it's based on inputs and outputs, not the specific language implementation."

---

## Malware: Understanding the Threat Landscape

### Malware vs. Vulnerable Software

| Aspect | Vulnerable Software | Malware |
|--------|---------------------|---------|
| **Purpose** | Legitimate functionality with flawed implementation | Malicious intent from the start |
| **Origin of Issue** | Programming errors, misconfiguration, oversight | Deliberate creation for harmful activity |
| **Exploitation** | Needs an attacker to discover and exploit the flaw | Intrinsically harmful; executes malicious actions itself |
| **Legality** | Typically legal software | Illegal or unauthorized software |

> "The key difference is in terms of purpose. Vulnerable software is not designed or developed to harm anyone. It serves useful purposes but has flaws. Malware is created to intentionally harm."

*Instructor Emphasis*: "Malware is malicious software that can be used to launch different attacks. It uses self-replicating code."

### Malware: Core Characteristics

Malware is defined by NIST as:
> "A program that is inserted into a system, usually covertly, with the intent of compromising the confidentiality, integrity or availability of the victim's data, applications, or operating system or otherwise annoying or disrupting the victim."

Malware can:
- Delete files
- Send spam email
- Launch DoS attacks
- Steal private information
- Record user inputs (keylogging, screen capture)
- Encrypt files and demand ransom (ransomware)
- Physically damage machines

> "The most dangerous aspect of malware is its ability to self-replicate. If malware just performed malicious actions, it would need to be very targeted, like giving someone a USB stick. But thanks to self-replication, it can spread worldwide."

*Instructor Insight*: "Botnets are a key use case for malware. A botnet is a set of compromised machines under central control. The owner of the botnet now owns a huge amount of resources that can be used for DoS attacks."

---

## Virus: The User-Action Required Malware

### Virus Characteristics
- **Requires user action to propagate** (e.g., opening a file, running an application)
- **Infection mechanism**: How it gets into the system (e.g., email attachments, USB drives)
- **Trigger**: Event that activates the payload (sometimes called a logic bomb)
- **Payload**: What the virus does (e.g., delete files, steal data)

#### Propagation Strategies
- Infect existing code that runs when users open apps or files
- Modify code to include malware (e.g., send emails with infected attachments)
- Copy code to removable media (e.g., USB drives)

*Instructor Example*: "When you download software from a website that claims to offer free apps, it may appear normal but contains malicious code running in the background without you knowing."

### Detection Strategies: Signature-Based Detection

Signature-based detection works by:
1. Converting software to binary
2. Comparing the hash of the binary with existing hashes in a database
3. If a match is found, the software is likely malware

> "Signature-based detection works well for many viruses because it compares the hash of the uploaded software with existing hashes of known malware."

*Instructor Emphasis*: "This is like having a fingerprint database for malware. If the fingerprint matches, it's likely malicious."

### The Arms Race: Polymorphic Code

Polymorphic code changes appearance each time it propagates to evade detection:
- Encrypts the virus code with a different key each time
- Includes the key and decryptor in the payload
- When executed, uses the key to decrypt the original code

> "Polymorphic code is like changing the appearance of a person each time they go out. They're still the same person, but they look different to avoid being recognized."

*Instructor Insight*: "Encryption is being used for obfuscation, not confidentiality. The goal is to evade detection by making the virus look different."

#### Polymorphic Code Example
```
Original Virus Code → Encrypted Virus Code + Key + Decryptor
```

*Instructor Emphasis*: "The key point is that the encrypted code doesn't look like existing malware, so signature-based detection won't catch it."

#### Detection Challenges for Polymorphic Code
- **Strategy #1**: Add a signature for detecting the decryptor code
  - *Issue*: Less code to match against → More false positives
  - *Issue*: The decryptor code could be scattered across memory

- **Strategy #2**: Safely check if code performs decryption
  - *Issue*: Legitimate programs might perform similar operations (e.g., decompressing ZIP files)
  - *Issue*: How long to let the code execute? The decryptor might activate after a long delay

---

## Worm: The Self-Propagating Malware

### Worm Characteristics
- **Does not require user action to propagate**
- **Infects already-running code** (e.g., network services)
- **Spreads exponentially** (1 → 2 → 4 → 8...)

> "The key difference between viruses and worms is that worms don't require user action to propagate. This makes them trickier to prevent."

*Instructor Insight*: "For viruses, if you don't download or open the app, it won't affect you. For worms, you might be infected just by connecting to the internet or sharing the same network with an infected machine."

#### Propagation Strategies
- **Random scanning**: Generate random IP addresses to connect to
- **Search worms**: Use Google searches to find victims
- **Scanning**: Look for targets (limited by bandwidth)
- **Target lists**: Pre-generated lists or lists stored on infected hosts
- **Passive**: Wait for another user to contact you, then reply with infection

*Instructor Example*: "WannaCry spread by aggressively scanning both local and random remote networks, attempting to exploit a vulnerability in the SMB file sharing service on unpatched Windows systems."

### Modeling Worm Propagation

Worm propagation follows a **logistic growth model**:
- Initial growth is exponential (more infected hosts = more opportunities to infect)
- Later growth slows down (harder to find new non-infected hosts)

> "Worm propagation can be modeled as an infectious epidemic, using the same models biologists use to model disease spread."

*Instructor Insight*: "This is why worms like WannaCry can spread extremely fast—within hours to days, infecting hundreds of thousands of systems across more than 150 countries."

#### Real-World Example: WannaCry
- **Ransomware attack** in May 2017
- Spread rapidly as a worm by scanning networks for SMB vulnerabilities
- **Killed by a "kill-switch"** domain accidentally activated by a UK security researcher
- Once installed, encrypted files and demanded ransom payment

---

## Rootkit: The Stealthy Malware

### Rootkit Characteristics
- **Hidden programs installed to maintain covert access**
- **Hides by subverting monitoring mechanisms** (processes, files, registries)
- **Gives attacker root privileges** (admin access)
- **Can add/change programs/files, monitor processes, send/receive network traffic**

> "Rootkits are malware in the operating system that hides its presence. They can replace system programs to hide their presence, like replacing 'ls' to hide malicious files."

*Instructor Example*: "A rootkit might replace 'ls' (list files) so when you run 'ls', it doesn't show malicious files. It might also replace 'ps' (list processes) to hide the rootkit process."

### Rootkit Strategies
1. **Hide stored malware** (report "file doesn't exist" when others try to read it)
2. **Hide running malware** (don't report the process when others list running processes)
3. **Hide inside startup code** (BIOS/EFI firmware, disk controller firmware)

*Instructor Emphasis*: "Rootkits are particularly dangerous because they can hide in firmware, making them very hard to detect and remove."

### Detection and Defense Strategies
- **Compare results of standard and non-standard programs**:
  - Compare 'ls' output with 'dirdump' (a non-standard program that directly reads directory entries)
  - If results differ, 'ls' may be compromised
- **Look for suspicious strings** in executable files
- **Verify file integrity** using cryptographic checksums

> "Rootkits often compromise standard system programs (e.g., ls, ps) to hide malicious files or processes. Using alternative tools that directly make system calls to the OS kernel allows you to bypass rootkit manipulation."

*Instructor Insight*: "If malware infected the tools used to rebuild the operating system, there's no good way of cleaning up malware using only tools in the system. Best solution: Rebuild the system from data backups and a fresh copy of the operating system."

---

## Polymorphic vs. Metamorphic Code

### Polymorphic Code
- Encrypts the virus with a different key each time
- Includes the key and decryptor in the payload
- **Advantage**: Simple to implement
- **Disadvantage**: Decryptor code can be detected

### Metamorphic Code
- Changes the code's semantics each time (without changing functionality)
- Uses a code rewriter to change code randomly
- **Advantages**: No decryptor code to detect; harder to detect
- **Disadvantage**: More complex to implement

> "Metamorphic code is like rewriting a book in different ways while keeping the same story. The words change, but the meaning stays the same."

*Instructor Insight*: "Metamorphic code can change the code's structure without changing functionality—like changing a for loop to a while loop, or using different algorithms (mergesort vs. quicksort)."

#### Metamorphic Code Example
```
Original Virus Code → Rewritten Virus Code (semantically different but same functionality)
```

*Instructor Emphasis*: "Metamorphic code is harder to detect than polymorphic code because it doesn't have a decryptor that can be identified."

---

## Malware Detection Strategies

### Signature-Based Detection
- Compares code against known malware signatures
- **Strength**: Effective for known malware
- **Weakness**: Easily evaded by polymorphic/metamorphic code

### Behavior-Based Detection
- Runs code in a sandbox to observe behavior
- **Strength**: Can detect new malware variants
- **Weakness**: May require significant resources

### Abnormal Detection
- Flags unfamiliar code (not in database)
- **Strength**: Works against polymorphic/metamorphic code
- **Weakness**: May produce false positives

> "Abnormal detection is powerful because it combines with signature-based detection. If malware tries to keep code the same, signature-based detection catches it. If it changes code, abnormal detection catches it."

*Instructor Insight*: "The two strategies work together: If the attacker doesn't modify the code, it has a detectable signature. If they modify it, it appears new and suspicious. When avoiding one strategy, the attacker will be caught by the other."

---

## Logging and Auditing: The Security Backbone

### Uses of Audit
- **Accountability & Compliance**: Deter misbehavior
- **Forensics & Event Reconstruction**: Determine what happened and how to recover
- **Problem Monitoring**: Real-time intelligence about system behavior

> "Logging is not just for security—it's a critical part of understanding system behavior and diagnosing issues."

*Instructor Emphasis*: "Logging is the key to understanding what's happening in your system. It's like having a time machine for your application."

### What to Log
- **Kernel and system services** (e.g., process accounting)
- **Application and server software** (e.g., Apache, cron)
- **Network devices** (e.g., using syslog or SNMP traps)

*Instructor Insight*: "On UNIX systems, most logs are stored under /var/log and /var/adm. Check syslog's configuration at /etc/syslog.conf to find other logs."

### Logging Levels
| Level | Numeric Value | Meaning |
|-------|---------------|---------|
| **DEBUG** | 10 | Detailed information for debugging |
| **INFO** | 20 | General information about program execution |
| **WARNING** | 30 | Potential problem that doesn't stop the program |
| **ERROR** | 40 | Serious issue preventing part of program from working |
| **CRITICAL** | 50 | Very severe error, possibly causing program to stop |

*Instructor Example*: 
```python
import logging
# Configure logging
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')

def process_payment(user, amount):
    logging.debug(f"Starting payment process for user: {user}, amount: {amount}")
    if not user:
        logging.error("No user information provided.")
        return False
    if amount <= 0:
        logging.warning("Payment amount is zero or negative.")
        return False
    try:
        logging.info("Connecting to payment gateway...")
        # Simulating a failure in payment gateway
        if amount > 1000:
            raise ConnectionError("Payment gateway timeout.")
        logging.info("Payment processed successfully.")
        return True
    except ConnectionError as e:
        logging.critical(f"Critical issue: {e}")
        return False
```

### Logging Best Practices

#### What to Log
- **Log what you mean**: Every log entry should say what it means without needing context
- **Log status and error conditions**: What's happening in the system

#### What NOT to Log
- **Plaintext keys and passwords**
- **Details of company products**
- **GPS coordinates of undercover agents**

> "Never log plaintext passwords or sensitive information. If you must log sensitive data, sanitize it by replacing with pseudonyms or using a secure mapping."

*Instructor Insight*: "Sanitization is critical. If you log sensitive information, you're creating a security risk. Protect confidential information by deleting or modifying it before logging."

#### Sanitization Strategies
- **Before writing to log**: Protect users from system administrators; surveillance may require probable cause
- **After writing to log**: Protect confidentiality of logs; can decide later what to discard

*Instructor Emphasis*: "The key principle is: Every log entry should say what it means. The reviewer should be able to recover the meaning without needing to assume or supply context."

---

## Summary: Key Takeaways

### Dynamic Analysis
- **Fuzzing** is a powerful technique for finding vulnerabilities by generating inputs:
  - *Mutation-based*: Simple, random modifications
  - *Generation-based*: Uses specifications to create valid inputs
  - *Coverage-guided*: Maximizes code path coverage
- **DAST** (Dynamic Application Security Testing) provides evidence of vulnerabilities but requires code to be executable
- **SAST** (Static Application Security Testing) examines code without execution but may produce false positives

### Malware
- **Malware** is malicious software with intentional harmful purpose, unlike **vulnerable software** (legitimate software with flaws)
- **Viruses** require user action to propagate; **worms** do not
- **Polymorphic code** encrypts malware with different keys each time; **metamorphic code** changes code semantics while maintaining functionality
- **Rootkits** hide by subverting monitoring mechanisms and can be extremely difficult to detect

### Logging and Auditing
- **Logging** provides critical insights into system behavior and is essential for security
- **Log levels** (DEBUG, INFO, WARNING, ERROR, CRITICAL) help prioritize information
- **Sanitize sensitive information** before logging to prevent security risks
- **Abnormal detection** (flagging unfamiliar code) is a powerful defense against polymorphic and metamorphic malware

---

## Study Questions

1. Explain the key difference between mutation-based and coverage-guided fuzzing. When would you choose one over the other?
2. Why is dynamic analysis more difficult to integrate into the SDLC than static analysis?
3. What are the three key characteristics that distinguish malware from vulnerable software?
4. How does polymorphic code evade signature-based detection? What are the limitations of this approach?
5. Describe the logistic growth model for worm propagation. Why does growth slow down later?
6. Why is rootkit detection particularly challenging compared to other malware types?
7. What is the key principle for effective logging? Provide an example of a poorly written log entry and how to improve it.
8. How does behavior-based detection differ from signature-based detection in malware analysis?
9. Why is it impossible to create a perfect algorithm for detecting all malware? How does this relate to the halting problem?
10. Explain how the WannaCry ransomware used a "kill-switch" and why this was significant.
11. What are the three main types of tests in the SDLC (unit, regression, integration) and how do they relate to dynamic analysis?
12. How does metamorphic code differ from polymorphic code in terms of implementation and detection challenges?
13. What are the two main strategies for detecting polymorphic code, and what are their limitations?
14. Why is it important to sanitize sensitive information before logging it?
15. How does the concept of "abnormal detection" work as a defense against polymorphic and metamorphic malware?
16. What are the key differences between SAST and DAST, and when would you use each?
17. Explain the role of the decryptor in polymorphic code and why it's a detection target.
18. How does the "arms race" between malware authors and antivirus companies manifest in the evolution of malware?
19. What are the main propagation strategies for worms, and how do they differ from virus propagation?
20. Why is it often impossible to remove rootkits without completely rebuilding the system?

---

## Practical Exercise

Create a simple Python program that:
1. Logs different types of messages at different levels (DEBUG, INFO, WARNING, ERROR, CRITICAL)
2. Includes a function that simulates a vulnerability (e.g., a buffer overflow)
3. Demonstrates how logging can help identify the vulnerability
4. Shows how sanitization would work for a sensitive field (e.g., password)

Write a short explanation of how your logging strategy follows the best practices discussed in the lecture.