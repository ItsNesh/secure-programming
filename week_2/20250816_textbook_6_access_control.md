<!-- 
Generated by LectureQ (Enhanced Comprehensive Version)
Date: 2025-08-16 05:38:38
Model: qwen3:30b
Output Mode: Comprehensive
-->

<think>
I'll create a comprehensive set of study notes based on Chapter 6 "Access Control" from Anderson's textbook. I need to extract all concepts, theories, principles, examples, and case studies with detailed explanations.

Let me organize the content by identifying key sections:

1. Introduction to Access Control (Slide 1-2)
2. Operating System Access Controls (Slides 3-16)
   - Access control matrices
   - Groups and roles
   - ACLs vs Capabilities
   - DAC vs MAC
   - OS-specific implementations (Unix, macOS, iOS, Android, Windows)
3. Middleware Access Control (Slide 17-20)
   - Database access controls
   - Browsers as middleware
4. Sandboxing & Virtualization (Slides 19-20)
5. Hardware Protection (Slides 21-25)
6. What Goes Wrong: Attacks and Vulnerabilities (Slides 25-32)
7. Remedies for Security Issues (Slide 32-33)
8. Environmental Creep & Summary (Slides 33-34)

I'll now create detailed study notes covering all these aspects with comprehensive explanations, definitions of key terms, examples from the text, and a summary section.

Let me start by creating hierarchical headers for organization as requested.
</think>

# Comprehensive Study Notes: Chapter 6 - Access Control

## Introduction to Access Control

### Core Concept
Access control is **the central pillar of computer security**, functioning to regulate which principals (persons, processes, machines) have access to which resources in a system. It controls:
- Which files users can read
- Which programs they can execute
- How data is shared between principals

> "Anything your computer can do for you it can potentially do for someone else." - A.L. Ox  
> "Security systems have an nasty habit of backfiring and there's no doubt they would cause enormous problems." - Rick Maybury

### Historical Context
Access control became the center of gravity in security from the 1970s onward, as computers evolved beyond single-user mainframes to multi-process environments. Early computing had physical security only (punched cards), but with time-sharing systems came the need for **protection mechanisms** preventing one program from interfering with another.

### Access Control Levels
Access control operates at multiple levels in a system:

| Level | Description | Example |
|-------|-------------|---------|
| Hardware | Processor and memory management controls | Memory protection, segmentation |
| Operating System | Controls access to files, ports, resources | File permissions on Linux/Windows |
| Middleware | Enforces security between applications | Web browsers, database systems |
| Application | Domain-specific policies for specific tasks | Bank call center restrictions |

> "As we work up from the hardware through the operating system and middleware to the application layer, the controls become progressively more complex and less reliable."

## Operating System Access Controls

### Core Mechanisms
#### 1. Access Control Matrix Model
A fundamental model representing access permissions as a matrix:

- **Columns**: Resources (files)
- **Rows**: Principals (users)

Permissions are represented by:
- `r` = read permission
- `w` = write permission
- `x` = execute permission
- `-` = no access

**Example Matrix (Figure 6.1):**
```
Operating Accounts Accounting Audit
System Program Data Trail
Sam       rwx   rwx    rw     -
Alice      x     x     rw     -
Bob        rx    r      r     r
```

*Interpretation:*
- Sam has full access to all resources except the audit trail (which he can only read)
- Alice needs to execute programs but not tamper with them; she must use approved interfaces
- Bob, as an auditor, can read everything

**Limitations:** 
This model doesn't scale well for large systems. A bank with 50,000 staff and 300 applications would require a matrix of **15 million entries**, creating performance overheads and administrative complexity.

#### 2. Access Control Matrix Variants
Two main approaches to managing the access control matrix:

| Approach | Description | Pros | Cons |
|----------|-------------|------|------|
| Column-based (ACL) | Store permissions per resource ("column") | Natural for user-managed security; common in Unix systems | Inefficient at runtime; hard to find all files a user can access |
| Row-based (Capabilities) | Store permissions per principal ("row") | Efficient for runtime checks; easy delegation | Hard to change file status; difficult to track who has access |

**Example of Capability (Figure 6.4):**
```
User      Operating System Program Accounts Data Audit Trail
Bob       rx          r        r     r
```

*Interpretation:* Bob's capabilities show he can read all resources.

### Groups and Roles

#### Key Concepts:
- **Group**: A list of principals (users)
- **Role**: A fixed set of access permissions that one or more principals may assume for a period of time

**Classic Role Example:** "Officer of the watch on a ship" - exactly one person holds this role at any given time with formal procedures for handover.

#### Implementation Challenges:
1. **Group vs Role Distinction**: 
   - *Groups* express organizational rank (e.g., manager)
   - *Roles* include specific permissions in context (e.g., "acting manager of Cambridge branch")

2. **Real-World Example**:
   > In banking: The manager of the Cambridge branch might have privileges expressed by membership of group `manager` and assumption of role `acting_manager_Cambridge_branch`. 
   > *Policy*: "Transfers over $10m must be approved by two staff, one with rank at least manager and one with rank at least assistant accountant."

3. **Security Implications**:
   - If the branch manager is sick, an assistant accountant acting as manager might need a second signature from regional head office.

### ACLs (Access Control Lists)

#### Implementation in Unix
Traditional Unix systems use `rwx` attributes for owner/group/world:

- First character: `-` = file, `d` = directory
- Next three characters (`rwx`): Owner permissions
- Middle three characters (`rwx`): Group permissions
- Last three characters (`rwx`): World (others) permissions

**Example ACL:**  
`drwxrwxrwx Alice Accounts` - Directory with all permissions for owner, group, and world.

**Real Example from Text:**
```
-rw-r----- Alice Accounts
```

*Interpretation:* 
- File type = regular file (`-`)
- Owner (Alice) can read/write (`rw`)
- Group members (Accounts) can only read (`r`)
- World has no access (`-`)

#### Limitations of Unix ACLs:
1. **Root Privilege Issue**: Root user (`uid=0`) bypasses all security checks
   - *Problem*: System administrator could modify audit trails, making it hard to defend against false accusations or cover up intrusions.
   - *Solution*: Traditional approach was sending logs to a printer in locked room; modern solution is separate logging server.

2. **SUID (Set-User-ID) Mechanism**:
   - Allows programs to run with owner's privileges rather than invoking user's
   - Example: Create `account-package` user owning file 2, mark as SUID, place in directory accessible by Alice
   
3. **Security Problems with SUID**:
   > "Programmers are often lazy or facing tight deadlines; so they just make the application suid root, so it can do anything."
   
   This practice leads to security holes because responsibility for access control moves from OS environment to applications.

4. **State Management Issues**: 
   - ACLs don't handle mutable state well (e.g., transactions requiring manager + accountant approval)
   - Hard to revoke access when employees are fired

5. **Single-User Limitation**:
   - Unix ACL only names one user
   - *Solution*: Older systems used groups; newer systems implement POSIX extended ACLs with multiple named users/groups.

### DAC (Discretionary Access Control) vs MAC (Mandatory Access Control)

#### Discretionary Access Control (DAC)
- **Definition**: Security policy is controlled by the owner of resources or system administrator
- **Model**: "You start your computer in supervisor mode and then, as the administrator, you can make less-privileged accounts available"
- **Example**: Traditional Unix systems where root user has complete control

#### Mandatory Access Control (MAC)
- **Definition**: Security policy is enforced by a central authority regardless of owner's actions
- **Origin**: Military research program in 1970s to protect classified information ("Top Secret" files can't be accessed by "Secret" clearance users)
- **Key Difference**: In MAC, the sysadmin isn't the boss; ultimate control rests with remote government authority setting security policy

#### Evolution of MAC:
| Era | Development |
|-----|-------------|
| 1970s | US military research for multilevel secure (MLS) systems |
| 1980s | Safety engineers develop safety integrity levels, similar to MLS concepts |
| 1990s | Creative industries lobby for DRM as form of MAC ("preventing sharing with non-subscribers") |
| Early 2000s | Microsoft and Intel incorporate MAC into products via Trusted Computing Group |

#### Modern Implementations:
- **Windows Vista (2006)**: Introduced trusted boot using TPM chips to prevent persistent malware
- **TPM (Trusted Platform Module)**: Smartcard chip on motherboard supporting trusted boot, hard disk encryption

> "The real supervisor on the system is no longer you, the machine owner – it's the operating-system vendor."

### OS-Specific Implementations of Access Control

#### 1. Unix Security Model
- **Root User**: Has unrestricted access; can do anything (access any file, become any user)
- **Security Issues**:
  - Difficulty implementing audit trails that root cannot modify
  - SUID programs often misused as `suid root` for convenience rather than necessity

#### 2. macOS Security Model
- Based on FreeBSD Unix with Mach kernel
- Default: Root account disabled; administrators in "wheel" group (can `su` to root)
- **Mandatory Access Control**: Since version 10.5 (Leopard), uses TrustedBSD variant for MAC protection of core system components

#### 3. iOS Security Model
- Based on Unix with Mach kernel and FreeBSD modifications
- **Key Features**:
  - Apps have *permissions* as capabilities (request access to services like camera, SMS)
  - Trust-on-first-use model: User consents when app first requests service
  - Closed ecosystem: iPhone only runs apps signed by Apple

> "The security of mobile devices is a rather complex issue involving not just access controls and tamper resistance but the whole ecosystem."

**Security Architecture Details (iOS):**
- **Secure Enclave**: Dedicated processor for sensitive operations (fingerprint, payments)
- **Key Management**: Unique 256-bit AES key burned into fusible links on system-on-chip
- **Passcode Handling**: Ten tries to enter passcode; keys derived from master key only after successful entry

#### 4. Android Security Model
- Based on Linux with apps running under different user IDs
- **Key Features**:
  - Apps have *permissions* as capabilities (request access to device services)
  - Signed packages (.apk files) using self-signed certificates as developer names
  - Permissions must be approved by users for "dangerous" permissions

> "Android is the world's most widely used operating system, with 2.5 billion active Android devices in May 2019."

**Evolution of Permission Model:**
- **Early Versions**: Required all permissions on installation or app wouldn't run
- **Problem**: Users clicked through everything (e.g., flashlight apps demanded address book access)
- **Android 6+**: Moved to Apple-style trust-on-first-use model

> "Since Android 5, SELinux has been used to harden the OS with MAC."

#### 5. Windows Security Model
**Evolution:**
1. **Early Versions (Pre-Windows NT)**: No access control - all software ran as root
2. **Windows NT**: First version with proper security model; inspired by Unix but extended:
   - Additional attributes beyond read/write/execute (`takeownership`, `changepermissions`, `delete`)
   - Multiple values for permissions (`AccessDenied`, `AccessAllowed`, `SystemAudit`)

3. **Active Directory** (Core of Windows Security):
   - Hierarchical namespace organizing users, groups, machines
   - Manages remote authentication via Kerberos or TLS

4. **Key Features in Modern Windows:**
   - **User Account Control (UAC)**: Replaced default admin privilege with user defaults; requires elevation prompts for privileged tasks
   - **Dynamic Access Control**: Controls access by context (work PC vs home PC, phone)
   - **Principals & Security Identifiers (SIDs)**: Represent users/computers/processes in security contexts

> "Windows evolved to provide a richer and more flexible set of access control tools than any system previously sold in mass markets."

**Why Windows is Complex:** 
Driven by corporate customers needing to manage tens of thousands of staff across hundreds of sites with internal controls limiting damage from dishonest staff or infected machines.

## Middleware Access Controls

### Database Security
Database security mechanisms are often more complex than OS-level controls:

| Feature | Description |
|---------|-------------|
| **Access Control Model** | Mix of ACLs and capabilities (privileges for both users and objects) |
| **Stateful Policies** | Prevent user from learning too much about customers; deal with statistical inference rather than simple yes/no rules |
| **Common Failure Mode** | Developers bypassing OS controls by using database accounts instead of operating system accounts |

> "In many installations, the database is accessible directly from outside; even where shielded by web service front-end, loopholes often let SQL code be inserted."

**Real-World Example:**
- **Slammer Worm (2003)**: Propagated via stack-overflow exploit against Microsoft SQL Server 2000
- Created massive traffic as compromised machines sent attack packets to random IP addresses

### Browser Security
Browsers are critical middleware platforms for access control:

**Core Protection Mechanism:** 
- **Same-Origin Policy**: JavaScript/active content can only communicate with the original domain it came from (enforced via sandboxing)

> "The browser is the place on your laptop where you run code written by people you don't want to trust and who will occasionally be malicious."

#### Common Browser Security Failures:
1. **Cross-Site Request Forgery (CSRF)**: 
   - Malicious website includes links/form buttons that execute actions when user clicks
   - Example URL: `https://mybank.com/transfer.cgi?amount=10000USD&recipient=thief`
   - *Countermeasures*: Short-lived sessions, anti-CSRF tokens (invisible MAC of session cookie), checking Referer header

2. **Cross-Origin Resource Sharing (CORS) Misconfigurations**:
   - Example: Amazon Alexa had misconfigured CORS policy allowing subdomain compromise to replace skills with malicious ones
   - *Result*: Anyone compromising another Amazon subdomain could replace target Alexa skills

## Sandboxing and Virtualization

### Sandboxing
- **Definition**: Restricted environment where code has no access to local hard disk (or limited temporary access) and can only communicate with host it came from.
- **Origin**: Introduced by Sun with Java programming language in late 1990s.

**How It Works:**
- Code executed by interpreter (Java Virtual Machine - JVM)
- Limited memory access rights
- Enforced via same-origin policy

> "This is enforced by having the code executed by an interpreter – the Java Virtual Machine (JVM) – with only limited access rights."

### Virtualization
**Definition**: Technology enabling a single machine to emulate multiple independent machines.

#### Evolution:
1. **Early 1960s**: IBM VM/370 partitioned mainframes into virtual machines for legacy app support.
2. **2003**: VMware ESX Server and Xen enabled cloud computing revolution by handling resource usage well.
3. **Modern Cloud Computing**: Powers data centers where users rent VMs for $10-$50/month.

**Security Implications:**
- **Hypervisor Security Claim**: VMM code can be smaller than OS, making it easier to review/secure
- **Reality Check**: "Whether there are actually fewer vulnerabilities is of course an empirical question."

#### Client-Side Virtualization:
- Allows running guest OS on host (e.g., Windows on macOS)
- Enables security separation: e.g., employee has two copies of Windows - one locked-down for office, another for home

**Real Example:** 
- **Samsung Knox**: Creates VM on mobile phone that employer can lock down and manage remotely while user enjoys normal Android.

#### Containerization (2010s):
- **Definition**: Lightweight alternative to virtualization; isolated guest process sharing kernel with other containers
- **Key Difference from VMs**:
  - VM: Complete OS insulated by hypervisor
  - Containers: Isolated processes sharing a kernel

> "Containers have been the hot new topic in late 2010s... they evolved as lightweight alternative to virtualization."

#### Security Issues with Containers:
- **Real Example (2019)**: Biometric identification service left entire database unprotected; researchers found millions of people's photos, fingerprints, passwords on unsecured Elasticsearch.
- **Hardware Limitations**: Meltdown and Spectre side-channel attacks undermine container/VM security.

## Hardware Protection

### Memory Management & Segmentation
**Classic Mechanism:** Segment addressing - memory addressed by two registers:
1. Segment register pointing to segment of memory
2. Address register pointing within that segment

> "The implementation has become more complex as processors themselves have."

#### Historical Processor Evolution:
- **IBM Mainframes**: Early systems had 2-state CPU (authorized vs non-authorized)
- **Multics (MIT, 1960s)**: Introduced rings of protection with varying privilege levels
  - Ring 0: Complete access to disk/supervisor state
  - Ring 2: Supervisor processes
  - User code at less privileged levels

### Intel Processors & Security Features

#### Key Developments:
| Year | Feature | Purpose |
|------|---------|---------|
| 1982 | Explicit parameter checking instructions (verify read/write/length) | Prevent stack overflows, but avoided by developers to prevent architecture dependencies |
| 2006 | Hardware support for virtualization (Intel VT-x) | Enable cloud computing; run unmodified OSes faster and more robustly |
| 2015 | Software Guard Extensions (SGX) | Create encrypted memory enclaves for trusted code execution |

**SGX Details:**
- **Memory Encryption Engine**: Encrypts enclave data
- **New Instructions & Memory Checks**: Prevent non-enclave processes from accessing enclave memory
- **Security Perimeter**: CPU itself; software is encrypted in main memory (costing time/space)
- **Current Vulnerabilities**: 
  - Return-oriented programming (ROP) attacks within enclaves
  - "Stealthy return-oriented programming" attacks on host apps

> "SGX has been promoted for DRM and securing cloud VMs, particularly those containing crypto keys or sensitive personal information; this is under threat from Spectre and similar attacks."

### Arm Processors & Security Features

#### Key Developments:
- **Arm Architecture**: Most common processor in phones/tablets/IoT devices
- **TrustZone (2004)**: "Two worlds" model for security
  - Open world: Normal OS/applications
  - Closed enclave: For sensitive operations (cryptography, critical I/O)
  
> "Phones were the 'killer app' for enclaves as operators wanted to lock subsidised phones and regulators wanted baseband software tamper-resistant."

**TrustZone Features:**
- Secure mode orthogonal to user/supervisor modes
- Hosts single trusted execution environment (TEE) with separate stacks, simplified OS
- Runs only signed code by OEM

> "Arm's latest offering is CHERI which adds fine-grained capability support to Arm CPUs... could prevent most zero-day exploits of recent years."

## What Goes Wrong: Security Vulnerabilities & Attacks

### Attack Types and Evolution

#### 1. Memory Overwriting (Stack Smashing)
- **Classic Exploit**: Morris worm in 1988
- **Mechanism**:
  - Program accepts input without size checking
  - Long argument overwrites stack, executing attacker's code
  - Landing pad: NOP instructions to catch processor execution

> "Attacks involving violations of memory safety accounted for well over half the exploits against operating systems in late 1990s and early 2000s."

**Example (Figure 6.5):**
```
Malicious argument → Overlong input buffer → Landing pad (NOP) → Malicious code
```

#### 2. Other Technical Attacks

| Attack Type | Description | Example |
|-------------|-------------|---------|
| **Use After Free** | Memory freed but still used, leading to malicious function invocation | Common in browser exploits; most common remote execution vulnerability today |
| **SQL Injection** | User input not sanitized before passing to database | Careless web developer passes user input containing SQL code directly to backend DB |
| **Race Conditions (TOCTTOU)** | Transaction carried out in stages with access rights verified at first stage, sensitive action done later; attacker alters state between steps | Early Unix `mkdir` vulnerability: Replace directory with link to password file during two-step process |

#### 3. Advanced Attack Techniques
- **Return-Oriented Programming (ROP)**:
  - Uses existing code ("gadgets") ending in return instructions
  - Assembles Turing-complete machine from these gadgets
  - Defeats Data Execution Prevention by using legitimate code

> "Many modern systems try to prevent type safety attacks... but an attacker can look for gadgets..."

- **Block-Oriented Programming (BOP)**:
  - Generates ROP chains automatically from crashes discovered via program fuzzing
  - Defeats current control-flow integrity controls

#### 4. Side Channel Attacks (2018)
| Attack | Target Processor | Mechanism |
|--------|------------------|-----------|
| **Meltdown** | Intel processors | Exploits out-of-order execution; leaks memory via cache timing differences |
| **Spectre** | Intel, AMD, Arm | Exploits speculative execution (predicting future instructions) |

> "The basic idea is that large modern CPUs' pipelines are so long and complex they look ahead... The path not taken can still load information into a cache..."

#### 5. User Interface Failures
- **Classic Example**: Windows confirmation dialogues trained users to click boxes away, combined with requiring administrator privileges for software installation.
  
> "Until 2006 a user needed to be the administrator to install anything... hundreds of millions had admin privileges they shouldn't have."

**Resulting Impact:**
- Malware ecosystem established in PC world
- Android ecosystem now developing similar issues as businesses pressure people to install apps rather than use websites

### Remedies for Security Vulnerabilities

#### 1. Technical Defenses:
| Defense | Year Introduced | Mechanism |
|---------|-----------------|-----------|
| **Stack Canaries** | ~2003 | Random number inserted next to return address on stack; if overwritten, canary changes |
| **Data Execution Prevention (DEP)** | 2003 (Windows XP) | Marks memory as data or code; prevents execution of data segments |
| **Address Space Layout Randomization (ASLR)** | ~2003 | Makes memory layout different in each system instance to prevent target address prediction |
| **Control Flow Integrity** | 2005 | Analyzes possible control-flow graph at compile time, enforces it at runtime |

#### 2. Better Tools:
- **Static Analysis Programs**: (e.g., Coverity) find potential software bugs early
- **Secure Programming Languages**: Rust replacing C/C++ for systems code

> "Rust emerged from Mozilla research in 2010 and has been used to redevelop Firefox; it's been voted the favorite language in Stack Overflow annual survey from 2016–2019."

#### 3. Better Training:
- Microsoft security initiative (2002): All programmers trained in secure coding
- Book: "Writing Secure Code" still worth reading

#### 4. DevSecOps Approach:
- Agile development methodology extended to rapid patch deployment and incident response
- Focuses effort on most urgent problems through continuous integration/continuous delivery pipelines

### Environmental Creep (Security Model Failure)

**Definition**: Security mechanisms that worked in initial environment fail when environmental changes occur.

**Unix Case Study:**
1. **Original Design**: "Single user Multics" - security for containing mistakes
2. **Evolution to Networked Systems**: 
   - Berkeley versions assumed extension from single machine to network of machines on one LAN under one management
   - Internet mechanisms (telnet, ftp) originally written for mainframes on secure networks with no transfer of authorization

> "The arrival of billions of phones... has left security engineers running ever faster to catch up."

**Key Environmental Changes:**
- From single machine → networked systems → internet
- From trusted users in lab setting → millions of untrusted apps from selfish/malicious authors
- From simple bugs → malicious code

## Summary and Key Takeaways

### Core Principles of Access Control
1. **Layering**: Security operates at multiple levels (hardware, OS, middleware, application)
2. **Trade-offs**: Higher-level mechanisms are more expressive but often less reliable
3. **Evolution**: Systems evolve beyond original security assumptions ("environmental creep")
4. **Complexity vs Usability**: More complex systems tend to have more vulnerabilities

### Security Model Evolution Timeline:
| Era | System Type | Primary Security Approach |
|-----|-------------|---------------------------|
| 1960s-70s | Mainframes, early time-sharing | Physical security; basic access control for contained environments |
| 1980s | Workstations, LANs | DAC (Discretionary Access Control) - owner-controlled permissions |
| Late 1980s-Early 2000s | Networked systems, Internet | MAC (Mandatory Access Control) research; early DRM attempts |
| Mid-2000s-Present | Mobile devices, cloud computing | Hybrid models with strong hardware security features |

### Key Security Failures by System Type:
1. **Unix**: SUID root programs bypassing proper access control
2. **Windows**: Default admin privileges for all users; poor user interface design leading to malware installation
3. **Mobile (iOS/Android)**: Overly permissive app permissions, lack of sandboxing in early implementations

### Modern Security Challenges:
- **Hardware Limitations**: Side-channel attacks undermining enclaves and containers
- **Ecosystem Complexity**: Mobile ecosystems require security beyond just access control mechanisms
- **Usability Issues**: Poor usability leads to insecure defaults (e.g., "allow all" permissions)

## Study Questions

1. Explain the difference between DAC and MAC, providing historical context for each.
2. Describe how a traditional Unix ACL works with an example of its limitations in modern environments.
3. What are capabilities? How do they differ from ACLs in terms of security checking efficiency?
4. Why did Windows Vista introduce User Account Control (UAC)? Explain the problem it was solving and what new vulnerabilities might have emerged as a result.
5. Describe how TrustZone works on Arm processors, including its two-world model and key components like TEE.
6. What is Meltdown/Spectre? How do they undermine traditional security models based on hardware isolation?
7. Compare and contrast the permission systems in iOS versus Android, highlighting similarities and differences.
8. Explain why stack smashing was such a prevalent attack vector historically, including how it worked with an example from the text (Morris worm).
9. What is "environmental creep" as described by Anderson? Provide specific examples of environmental changes that undermined security models over time.
10. How does SELinux differ from traditional Unix access control mechanisms?
11. Explain why Windows evolved to have such a complex access control system, and what business drivers led to this complexity.
12. Describe the concept of "least privilege" as it relates to secure software design, and provide examples where failing to implement least privilege has caused security issues.
13. What is CHERI? How does it differ from existing capability systems like those in SGX or TrustZone?
14. Explain how SQL injection attacks work at a technical level, including why they're so prevalent despite being well-known for decades.
15. Describe the evolution of browser-based security mechanisms (from same-origin policy to modern content security policies), and explain what limitations remain today.
16. What is "return-oriented programming" (ROP)? How does it bypass traditional defenses like DEP?
17. Why did Microsoft's Palladium project fail, despite being built on similar concepts as later technologies like SGX? 
18. Explain the concept of a secure enclave and why hardware-based enclaves are still vulnerable to side-channel attacks.
19. Describe how container security differs from traditional VM security in terms of attack surface and potential vulnerabilities.
20. What is "environmental creep" according to Anderson, and provide three specific examples where it has led to significant security failures?

## Key Terms Glossary

| Term | Definition |
|------|------------|
| **Access Control Matrix** | Fundamental model representing access permissions as a matrix with resources (columns) and principals (rows). |
| **DAC (Discretionary Access Control)** | Security policy controlled by resource owners or system administrators. |
| **MAC (Mandatory Access Control)** | Security policy enforced by central authority regardless of owner's actions; common in military systems. |
| **ACL (Access Control List)** | Column-based access control mechanism storing permissions per resource. |
| **Capability** | Row-based access control mechanism representing a principal's rights to resources, enabling delegation and efficient runtime checks. |
| **SUID (Set-User-ID)** | Unix file attribute allowing program to run with owner's privileges rather than invoking user's. |
| **TPM (Trusted Platform Module)** | Hardware chip on motherboard supporting trusted boot and hard disk encryption in modern systems. |
| **TrustZone** | Arm security extension implementing "two worlds" model for mobile devices: open world for normal apps, closed enclave for sensitive operations. |
| **SGX (Software Guard Extensions)** | Intel technology creating encrypted memory enclaves where code can run securely while other processes are isolated from it. |
| **Same-Origin Policy** | Browser security mechanism preventing JavaScript/active content on one domain from interacting with another domain's resources. |
| **TOCTTOU (Time-of-Check-to-Time-of-Use)** | Race condition vulnerability occurring when a transaction is carried out in stages, allowing state alteration between checks and use. |
| **ROP (Return-Oriented Programming)** | Attack technique using existing code ("gadgets") ending with return instructions to assemble malicious execution sequences without injecting new code. |
| **Environmental Creep** | Security failures resulting from environmental changes undermining original security models that worked in initial contexts but failed when scaled or adapted. |

## Further Reading Recommendations

1. *Computer Security* by Dieter Gollmann - Standard reference on access control issues
2. *Software Security* by Gary McGraw (2006) and updated editions for current attack techniques
3. "A History of Virtualisation" by Allison Randal [1578]
4. Research papers from the Cloud Native Security Foundation regarding container security practices
5. Project Zero blog at Google - Detailed analysis of real-world attacks on modern operating systems with MAC components

> "The most detail on current attacks is probably in Google's Project Zero blog; see for example their analysis of attacks on iPhones found in the wild."