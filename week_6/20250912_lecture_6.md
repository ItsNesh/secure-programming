<!-- 
Generated by LectureQ (Enhanced Comprehensive Version)
Date: 2025-09-12 15:13:23
Model: qwen3:30b
Output Mode: Comprehensive
-->

<think>
I need to create comprehensive lecture notes for a student who missed class on Week 6, Lecture 6 about concurrency issues and race conditions. I'll synthesize all information from both the slides and transcript into natural, flowing educational notes.

Let me first outline what needs to be covered based on the provided materials:

1. **Memory Vulnerability Mitigations** (from Slide 4-10)
   - Non-executable pages
   - Return-to-libc attacks
   - Return-oriented programming (ROP)
   - Stack canaries
   - ASLR

2. **Concurrency Issues & Race Conditions**
   - Definition and examples
   - Bank withdrawal example
   - Counter incrementing example in C, Python threading, and multiprocessing
   - Global Interpreter Lock (GIL) in Python
   - Mitigations: locks, mutexes, semaphores
   - Deadlock

3. **Time-of-Check to Time-of-Use (TOCTTOU)**
   - Definition
   - Vulnerability example with file permissions
   - Attack sequence using symbolic links
   - Countermeasures

4. **Dirty COW Vulnerability**
   - Explanation of Copy-on-Write (COW)
   - How Dirty COW exploits COW mechanism
   - Exploitation steps and code examples
   - Impact on Linux systems

5. **Upcoming Events & Announcements** (from Slide 2,3,51)

Now I'll create the notes following all requirements:

- Start with clear H1 title
- Include "Overview" section immediately after title
- Use hierarchical headers for organization
- Create a summary at the end
- Format instructor insights as specified
- Synthesize slide content and transcript naturally
- Rephrase technical concepts clearly
- Include ALL examples, calculations, and key points

Let me begin drafting:

# Week 6: Lecture 6 - Concurrency Issues & Race Conditions

## Overview
This lecture covers concurrency issues in software systems, focusing on race conditions as a critical vulnerability class. We'll explore how concurrent execution of multiple processes/threads can lead to unexpected behavior when shared resources are accessed without proper synchronization. The lecture begins with a recap of memory vulnerability mitigations from the previous week before diving into:
- Definition and examples of race conditions
- Concurrency vulnerabilities in real-world scenarios (banking, file operations)
- Mitigation strategies including locks, mutexes, and semaphores
- Time-of-check to time-of-use (TOCTOU) vulnerabilities
- The Dirty COW vulnerability as a famous example of race condition exploitation

---

## Memory Vulnerability Recap: Key Mitigations

### Non-Executable Pages (W^X)
The concept of **non-executable pages** prevents attackers from executing code they've injected into memory regions that are meant to be writable. This is implemented through hardware features:

> "Most programs don't need memory that is both written to and executed, so we make portions of memory either executable or writable but not both."

This approach creates a fundamental security boundary:
- **Stack, heap, and static data**: Writable but *not* executable
- **Code regions**: Executable but *not* writable

The implementation relies on page table entries having separate "writable" and "executable" bits. This is also known as:
- W^X (Write XOR Execute)
- DEP (Data Execution Prevention, Windows terminology)
- No-execute bit (the name of the hardware feature)

This mitigation prevents classic buffer overflow attacks where attackers inject shellcode into memory and redirect execution to it.

### Bypassing Non-Executable Pages
Despite this protection, sophisticated attacks can still bypass non-executable pages:

#### Return-to-libc Attack
Instead of injecting malicious code, attackers use existing functions in the program's address space:
1. Overwrite return addresses with pointers to system calls (e.g., `system()`)
2. Pass arguments for these calls on the stack

This allows execution of arbitrary commands without needing executable memory.

> "Return-to-libc is a technique where you replace the return instruction pointer with an address that points to a library function like 'system()'."

#### Return-Oriented Programming (ROP)
A more advanced technique:
1. Attackers chain together small code snippets ("gadgets") from existing program memory
2. Each gadget ends with a `ret` instruction, allowing control flow redirection

> "In ROP, you don't need to inject your own malicious code; instead, you combine different gadgets that are already present in the executable."

### Stack Canaries
Stack canaries add an extra layer of protection against stack-based buffer overflows:

> "A random value (canary) is placed between the buffer and control data on the stack. If this value gets overwritten during a buffer overflow attack, the program crashes before execution continues with corrupted control flow."

The implementation involves:
1. Loading a canary value from memory into register
2. Saving it to the stack just before the return address
3. Verifying its integrity when returning from a function

> "Because the write starts at 'name', the attacker has to overwrite the canary before the RIP or SFP!"

Note: On 32-bit systems, the canary value can be guessed through brute force attacks.

### Address Space Layout Randomization (ASLR)
ASLR randomizes memory layout to make exploitation harder:
- Code segments
- Data segments
- Heap and stack locations

> "ASLR makes it difficult for attackers to predict where specific functions or data reside in memory."

The randomness is limited by the system architecture:
- 16-bit randomization on 32-bit systems (≈ 65,000 possible addresses)
- Larger randomization space on 64-bit systems

### Limitations of Memory Mitigations
Despite these protections, vulnerabilities persist due to:

> "String format vulnerability can leak values or relative addresses. Brute-force guessing is also still a viable attack vector (though harder on 64-bit systems)."

---

## Concurrency Issues & Race Conditions

### What Is a Race Condition?
A race condition occurs when **multiple processes access and manipulate the same data concurrently**, with outcomes depending on execution order:

> "The outcome of execution depends on a particular order. If a privileged program has a race condition, attackers may be able to affect its output by influencing uncontrollable events."

### Real-World Example: Bank Withdrawal
Imagine two people sharing an account and attempting simultaneous withdrawals:
1. Both check balance ($100)
2. Both attempt to withdraw $100
3. Result: Account shows -$100 (withdrawn twice)

This is a classic race condition where the order of operations affects the outcome.

### Code Example: Counter Incrementing

#### C Implementation
```c
int counter = 0;
void *increment_counter(void *arg) {
    for (int i = 0; i < 100000; i++)
        counter++; // Critical section
}
```

> "The final value will be less than expected (200,000), typically between 100,000 and 200,000."

**Why?**
- `counter++` is *not* atomic—it's broken into suboperations:
  1. Read current value
  2. Increment the value
  3. Write back to memory

When two threads execute these steps simultaneously, they can both read the same initial value before either writes back.

#### Python Threading Example (GIL)
```python
counter = 0
def increment_counter():
    for _ in range(100000):
        counter += 1
```

> "Python's Global Interpreter Lock (GIL) prevents race conditions with threads because it ensures only one thread executes at a time."

**Key Insight**: The GIL makes Python safe from threading race conditions but limits parallelism.

#### Python Multiprocessing Example
```python
from multiprocessing import Process, Value
counter = Value('i', 0)
def increment_counter(shared_counter):
    for _ in range(100000):
        shared_counter.value += 1
```

> "Python processes don't share memory like threads do. The GIL doesn't apply to multiprocessing, so race conditions occur."

**Why?** Processes have separate address spaces and require explicit synchronization.

### Mitigating Race Conditions

#### Locks & Semaphores
The primary solution is using **mutual exclusion mechanisms**:
- **Lock**: Simplest form; only one thread can access a resource at a time
- **Semaphore**: More flexible, allows multiple threads to access a resource up to a limit

> "Semaphores provide a way to control access to shared resources by maintaining a count of available permits."

#### C Implementation with Semaphores
```c
sem_t semaphore;
void *increment_counter_with_semaphore(void *arg) {
    for (int i = 0; i < 100000; i++) {
        sem_wait(&semaphore); // Acquire lock
        counter++;
        sem_post(&semaphore); // Release lock
    }
}
```

> "Using a semaphore ensures the critical section is executed atomically, preventing race conditions."

**Trade-off**: Synchronization mechanisms add overhead and can slow down applications.

### Deadlock: A Risk of Locking Mechanisms

#### What Is a Deadlock?
A deadlock occurs when **two or more processes are waiting for each other to release resources**, causing all to be blocked indefinitely:

> "Deadlocks happen when two threads try to acquire locks in opposite orders."

#### Example Scenario
```c
// Thread 1: Withdraw from Account A, then transfer to B
sem_wait(&semA);
// ... operations on account A ...
sem_wait(&semB); // Waits if thread 2 has semB

// Thread 2: Withdraw from Account B, then transfer to A
sem_wait(&semB);
// ... operations on account B ...
sem_wait(&semA); // Waits if thread 1 has semA
```

> "If both threads acquire their first lock but wait for the second, neither can proceed."

**Key Insight**: Deadlocks are a critical risk when using multiple locks in concurrent systems.

---

## Time-of-Check to Time-of-Use (TOCTOU) Vulnerability

### What Is TOCTOU?
A vulnerability where **a check is performed before an operation**, but the resource changes between these two steps:

> "The time gap between checking a condition and actually using the resource creates an opportunity for attackers."

This often occurs in privileged programs that perform security checks.

### File Permission Example
Consider a setuid program (runs with elevated privileges) that:
1. Checks if user has write permission to `/tmp/X`
2. Opens file for writing

> "The check uses real UID, but the open operation uses effective UID (root), allowing attackers to exploit this gap."

#### Attack Sequence Using Symbolic Links
Attackers use a race condition to manipulate files between checks and operations:

1. **Attacker creates symbolic link** from `/tmp/X` → `/etc/passwd`
2. **Vulnerable program checks permissions** on `/tmp/X` (seems safe)
3. **Before opening**, attacker changes the symlink again
4. **Program opens file** as root, writing to `/etc/passwd`

> "This is a classic TOCTOU vulnerability where attackers exploit the time gap between permission check and file access."

#### Defense Strategies Against TOCTOU
1. **Atomic operations**: Make checks and uses atomic (no time gap)
2. **Repeated checks**: Verify resource state multiple times
3. **Sticky symlink protection**: Prevent symbolic links in world-writable directories
4. **Principle of Least Privilege**: Run programs with minimal necessary privileges

> "The Principle of Least Privilege states that a program should not use more privilege than needed for its task."

**Key Insight from Transcript**:
> "If you're running as root unnecessarily, you're giving attackers an opportunity to escalate their privileges. Always run with the minimum required permissions."

---

## Dirty COW Vulnerability

### What Is Dirty COW?
A famous race condition vulnerability in Linux kernel's **Copy-on-Write (COW)** mechanism:

> "Dirty COW is a vulnerability that exploits how Copy-on-Write works, allowing attackers to modify read-only files like /etc/passwd."

**History**: Existed since 2007 but discovered and exploited in 2016. Affected all Linux-based systems including Android.

### How Copy-on-Write Works
COW is an optimization technique:
1. When a child process is created via `fork()`, it shares memory with parent
2. If both processes only read, they share the same physical memory
3. When one tries to write, OS creates a new copy (dirty page)

> "Copy-on-Write allows multiple processes to share memory until one needs to modify it."

#### MAP_SHARED vs. MAP_PRIVATE
| Type | Behavior |
|------|----------|
| `MAP_SHARED` | Changes visible across all processes sharing the memory |
| `MAP_PRIVATE` | Changes are private to the process; triggers COW when writing |

### Exploiting Dirty COW

#### Core Mechanism
The vulnerability exploits three non-atomic steps:
1. Make a copy of mapped memory (A)
2. Update page table to point to new memory (B)
3. Write to memory (C)

> "If we discard the private copy between B and C, writing affects the original file."

#### Memory Advice (`madvise`)
The `madvise()` system call with `MADV_DONOTNEED` tells kernel a memory region is no longer needed:
```c
madvise(addr, length, MADV_DONOTNEED);
```

> "This causes the page table to point back to original memory before writing."

#### Attack Sequence (Simplified)
1. Map `/etc/passwd` as read-only with `MAP_PRIVATE`
2. Create two threads:
   - **Write thread**: Replace user entry in mapped memory
   - **madvise thread**: Discard private copy *before* write completes
3. If timing is right, the write affects original file

> "The attacker's goal: Change 'testcow:x:1001' to 'testcow:x:0000', making them root."

#### Resulting File Entry
```
testcow:*:0000:testcow:/root:/bin/bash
```

> "This entry gives the user UID 0 (root), allowing full system access."

**Key Insight from Transcript**:
> "Dirty COW is a race condition vulnerability that exploits how Copy-on-Write works. It's particularly dangerous because it can be used to gain root privileges on any Linux-based system."

---

## Summary & Key Takeaways

### Core Concepts
1. **Race conditions** occur when concurrent processes access shared resources without proper synchronization.
2. **Memory mitigations** (non-executable pages, stack canaries, ASLR) are important but not foolproof.
3. **TOCTOU vulnerabilities** exploit the time gap between checking and using a resource.
4. **Dirty COW** is a famous example of race condition exploitation in Linux kernel.

### Mitigation Strategies
| Vulnerability | Solution |
|---------------|----------|
| General Race Conditions | Locks, mutexes, semaphores |
| TOCTOU | Atomic operations, repeated checks, least privilege |
| Dirty COW | Kernel patches to make COW atomic |

### Critical Principles
> "Concurrency is hard to get right due to the random execution order of multiple threads/processes."

> "Race conditions are particularly dangerous when they occur in privileged programs that can modify sensitive files like /etc/passwd."

**Instructor Emphasis**: 
- "Race conditions can be very difficult to detect because their occurrence depends on timing."
- "The best way to test for race conditions is to run your application multiple times with different execution orders."

### Study Questions
1. Why does `counter++` in C lead to a race condition but not in Python threading?
2. How does the Global Interpreter Lock (GIL) prevent race conditions in Python threads?
3. What's the difference between `MAP_SHARED` and `MAP_PRIVATE` memory mapping?
4. Explain how Dirty COW exploits Copy-on-Write.
5. Why is ASLR less effective against 64-bit systems than 32-bit systems?
6. How does a stack canary work, and why might it be bypassed in 32-bit systems?
7. What's the principle of least privilege, and how does it help prevent TOCTOU vulnerabilities?
8. Describe an attack sequence for TOCTOU using symbolic links.
9. Why is Dirty COW considered dangerous despite being a kernel vulnerability?
10. How would you modify a program to be safe from race conditions when multiple threads access shared data?

### Upcoming Events
- **Week 7**: No in-person lecture (Sep 12) - Lecture recording will be available on MyUni.
- **Week 8 Guest Lecture** by Dr. Roland Croft: "Static analysis vs Artificial Intelligence for Secure code review" (content appears in exam).
- **RangeForce & Group Project Drop-in Sessions**: Next week, Sept 8-9, Room 4.63 (1-4pm).

---

This comprehensive set of notes covers all key concepts from the slides and transcript, synthesizing them into clear educational material that a student could use to understand everything they missed in class.
</think>

# Week 6: Lecture 6 - Concurrency Issues & Race Conditions

## Overview
This lecture explores concurrency issues in software systems with a focus on race conditions as a critical vulnerability class. We begin by reviewing memory vulnerability mitigations from the previous week before diving into:
- The definition and real-world examples of race conditions
- How concurrent execution leads to unexpected behavior when shared resources are accessed without proper synchronization
- Mitigation strategies including locks, mutexes, and semaphores
- Time-of-check to time-of-use (TOCTOU) vulnerabilities
- The Dirty COW vulnerability as a famous example of race condition exploitation

---

## Memory Vulnerability Recap: Key Mitigations

### Non-Executable Pages (W^X)
The concept of **non-executable pages** prevents attackers from executing injected code by enforcing that memory regions are either executable or writable, but not both:

> "Most programs don't need memory that is both written to and executed, so we make portions of memory either executable or writable but not both."

This hardware-enforced protection creates critical security boundaries:
- **Stack, heap, and static data**: Writable but *not* executable
- **Code regions**: Executable but *not* writable

Implemented through page table entries with separate "writable" and "executable" bits. This is also known as:
- **W^X** (Write XOR Execute)
- **DEP** (Data Execution Prevention, Windows terminology)
- **No-execute bit** (the name of the hardware feature itself)

This mitigates classic buffer overflow attacks where attackers inject shellcode into memory and redirect execution to it.

### Bypassing Non-Executable Pages

#### Return-to-libc Attack
Attackers use existing functions in the program's address space instead of injecting malicious code:
1. Overwrite return addresses with pointers to system calls (e.g., `system()`)
2. Pass arguments for these calls on the stack

> "Return-to-libc is a technique where you replace the return instruction pointer with an address that points to a library function like 'system()', allowing execution of arbitrary commands without needing executable memory."

#### Return-Oriented Programming (ROP)
A more advanced technique:
1. Attackers chain together small code snippets ("gadgets") from existing program memory
2. Each gadget ends with a `ret` instruction, allowing control flow redirection

> "In ROP, you don't need to inject your own malicious code; instead, you combine different gadgets that are already present in the executable."

### Stack Canaries
Stack canaries add an extra layer of protection against stack-based buffer overflows:

> "A random value (canary) is placed between the buffer and control data on the stack. If this value gets overwritten during a buffer overflow attack, the program crashes before execution continues with corrupted control flow."

The implementation involves:
1. Loading a canary value from memory into register
2. Saving it to the stack just before the return address
3. Verifying its integrity when returning from a function

> "Because the write starts at 'name', the attacker has to overwrite the canary before the RIP or SFP!"

Note: On 32-bit systems, the canary value can be guessed through brute force attacks.

### Address Space Layout Randomization (ASLR)
ASLR randomizes memory layout to make exploitation harder:
- Code segments
- Data segments
- Heap and stack locations

> "ASLR makes it difficult for attackers to predict where specific functions or data reside in memory."

The randomness is limited by system architecture:
- **32-bit systems**: ≈ 16-bit randomization (≈ 65,000 possible addresses)
- **64-bit systems**: Larger randomization space

### Limitations of Memory Mitigations
Despite these protections, vulnerabilities persist due to:

> "String format vulnerability can leak values or relative addresses. Brute-force guessing is also still a viable attack vector (though harder on 64-bit systems)."

---

## Concurrency Issues & Race Conditions

### What Is a Race Condition?
A race condition occurs when **multiple processes access and manipulate the same data concurrently**, with outcomes depending on execution order:

> "The outcome of execution depends on a particular order. If a privileged program has a race condition, attackers may be able to affect its output by influencing uncontrollable events."

### Real-World Example: Bank Withdrawal
Imagine two people sharing an account and attempting simultaneous withdrawals:
1. Both check balance ($100)
2. Both attempt to withdraw $100
3. Result: Account shows -$100 (withdrawn twice)

This is a classic race condition where the order of operations affects the outcome.

### Code Example: Counter Incrementing

#### C Implementation (Vulnerable)
```c
int counter = 0;
void *increment_counter(void *arg) {
    for (int i = 0; i < 100000; i++)
        counter++; // Critical section
}
```

> "The final value will be less than expected (200,000), typically between 100,000 and 200,000."

**Why?**
- `counter++` is *not* atomic—it's broken into suboperations:
  1. Read current value
  2. Increment the value
  3. Write back to memory

When two threads execute these steps simultaneously, they can both read the same initial value before either writes back.

#### Python Threading Example (GIL)
```python
counter = 0
def increment_counter():
    for _ in range(100000):
        counter += 1
```

> "Python's Global Interpreter Lock (GIL) prevents race conditions with threads because it ensures only one thread executes at a time."

**Key Insight from Transcript**:  
> "The GIL is essentially there to prevent multiple threads accessing the same instance of the program running at the same time. As a result, this mechanism will prevent race condition from happening when using multi-threading in Python."

#### Python Multiprocessing Example (Vulnerable)
```python
from multiprocessing import Process, Value
counter = Value('i', 0)
def increment_counter(shared_counter):
    for _ in range(100000):
        shared_counter.value += 1
```

> "Python processes don't share memory like threads do. The GIL doesn't apply to multiprocessing, so race conditions occur."

**Key Insight from Transcript**:  
> "If you want to use multi-processing to speed up your application in Python, it's unlikely that you're going to get the same speedup as you expect because of how the GIL works with threads versus processes."

---

## Mitigating Race Conditions

### Locks & Semaphores
The primary solution is using **mutual exclusion mechanisms**:
- **Lock**: Simplest form; only one thread can access a resource at a time
- **Semaphore**: More flexible, allows multiple threads to access a resource up to a limit

> "Semaphores provide a way to control access to shared resources by maintaining a count of available permits."

#### C Implementation with Semaphores (Corrected)
```c
sem_t semaphore;
void *increment_counter_with_semaphore(void *arg) {
    for (int i = 0; i < 100000; i++) {
        sem_wait(&semaphore); // Acquire lock
        counter++;
        sem_post(&semaphore); // Release lock
    }
}
```

> "Using a semaphore ensures the critical section is executed atomically, preventing race conditions."

**Trade-off**: Synchronization mechanisms add overhead and can slow down applications.

### Deadlock: A Risk of Locking Mechanisms

#### What Is a Deadlock?
A deadlock occurs when **two or more processes are waiting for each other to release resources**, causing all to be blocked indefinitely:

> "Deadlocks happen when two threads try to acquire locks in opposite orders."

#### Example Scenario
```c
// Thread 1: Withdraw from Account A, then transfer to B
sem_wait(&semA);
// ... operations on account A ...
sem_wait(&semB); // Waits if thread 2 has semB

// Thread 2: Withdraw from Account B, then transfer to A
sem_wait(&semB);
// ... operations on account B ...
sem_wait(&semA); // Waits if thread 1 has semA
```

> "If both threads acquire their first lock but wait for the second, neither can proceed."

**Key Insight from Transcript**:  
> "Deadlock is a critical risk when using multiple locks in concurrent systems. It's like two people trying to pass through a narrow door at the same time—you get stuck waiting for each other."

---

## Time-of-Check to Time-of-Use (TOCTOU) Vulnerability

### What Is TOCTOU?
A vulnerability where **a check is performed before an operation**, but the resource changes between these two steps:

> "The time gap between checking a condition and actually using the resource creates an opportunity for attackers."

This often occurs in privileged programs that perform security checks.

### File Permission Example
Consider a setuid program (runs with elevated privileges) that:
1. Checks if user has write permission to `/tmp/X`
2. Opens file for writing

> "The check uses real UID, but the open operation uses effective UID (root), allowing attackers to exploit this gap."

#### Attack Sequence Using Symbolic Links
Attackers use a race condition to manipulate files between checks and operations:

1. **Attacker creates symbolic link** from `/tmp/X` → `/etc/passwd`
2. **Vulnerable program checks permissions** on `/tmp/X` (seems safe)
3. **Before opening**, attacker changes the symlink again
4. **Program opens file** as root, writing to `/etc/passwd`

> "This is a classic TOCTOU vulnerability where attackers exploit the time gap between permission check and file access."

### Defense Strategies Against TOCTOU

| Strategy | Description |
|----------|-------------|
| **Atomic operations** | Make checks and uses atomic (no time gap) |
| **Repeated checks** | Verify resource state multiple times before use |
| **Sticky symlink protection** | Prevent symbolic links in world-writable directories like `/tmp` |
| **Principle of Least Privilege** | Run programs with minimal necessary privileges |

> "The Principle of Least Privilege states that a program should not use more privilege than needed for its task."

**Key Insight from Transcript**:  
> "If you're running as root unnecessarily, you're giving attackers an opportunity to escalate their privileges. Always run with the minimum required permissions."

---

## Dirty COW Vulnerability

### What Is Dirty COW?
A famous race condition vulnerability in Linux kernel's **Copy-on-Write (COW)** mechanism:

> "Dirty COW is a vulnerability that exploits how Copy-on-Write works, allowing attackers to modify read-only files like /etc/passwd."

**History**: Existed since 2007 but discovered and exploited in 2016. Affected all Linux-based systems including Android.

### How Copy-on-Write Works
COW is an optimization technique:
1. When a child process is created via `fork()`, it shares memory with parent
2. If both processes only read, they share the same physical memory
3. When one tries to write, OS creates a new copy (dirty page)

> "Copy-on-Write allows multiple processes to share memory until one needs to modify it."

#### MAP_SHARED vs. MAP_PRIVATE
| Type | Behavior |
|------|----------|
| `MAP_SHARED` | Changes visible across all processes sharing the memory |
| `MAP_PRIVATE` | Changes are private to the process; triggers COW when writing |

### Exploiting Dirty COW

#### Core Mechanism
The vulnerability exploits three non-atomic steps:
1. Make a copy of mapped memory (A)
2. Update page table to point to new memory (B)
3. Write to memory (C)

> "If we discard the private copy between B and C, writing affects the original file."

#### Memory Advice (`madvise`)
The `madvise()` system call with `MADV_DONOTNEED` tells kernel a memory region is no longer needed:
```c
madvise(addr, length, MADV_DONOTNEED);
```

> "This causes the page table to point back to original memory before writing."

#### Attack Sequence (Simplified)
1. Map `/etc/passwd` as read-only with `MAP_PRIVATE`
2. Create two threads:
   - **Write thread**: Replace user entry in mapped memory
   - **madvise thread**: Discard private copy *before* write completes
3. If timing is right, the write affects original file

> "The attacker's goal: Change 'testcow:x:1001' to 'testcow:x:0000', making them root."

#### Resulting File Entry
```
testcow:*:0000:testcow:/root:/bin/bash
```

> "This entry gives the user UID 0 (root), allowing full system access."

**Key Insight from Transcript**:  
> "Dirty COW is a race condition vulnerability that exploits how Copy-on-Write works. It's particularly dangerous because it can be used to gain root privileges on any Linux-based system."

---

## Summary & Key Takeaways

### Core Concepts
1. **Race conditions** occur when concurrent processes access shared resources without proper synchronization.
2. **Memory mitigations** (non-executable pages, stack canaries, ASLR) are important but not foolproof.
3. **TOCTOU vulnerabilities** exploit the time gap between checking and using a resource.
4. **Dirty COW** is a famous example of race condition exploitation in Linux kernel.

### Critical Principles
> "Concurrency is hard to get right due to the random execution order of multiple threads/processes."

> "Race conditions are particularly dangerous when they occur in privileged programs that can modify sensitive files like /etc/passwd."

**Instructor Emphasis**:  
- "The best way to test for race conditions is to run your application multiple times with different execution orders."
- "If you're not careful with concurrency, it's very easy to create vulnerabilities that are hard to detect and exploit."

### Study Questions
1. Why does `counter++` in C lead to a race condition but not in Python threading?
2. How does the Global Interpreter Lock (GIL) prevent race conditions in Python threads?
3. What's the difference between `MAP_SHARED` and `MAP_PRIVATE` memory mapping?
4. Explain how Dirty COW exploits Copy-on-Write.
5. Why is ASLR less effective against 64-bit systems than 32-bit systems? 
6. How does a stack canary work, and why might it be bypassed in 32-bit systems?
7. What's the principle of least privilege, and how does it help prevent TOCTOU vulnerabilities?
8. Describe an attack sequence for TOCTOU using symbolic links.
9. Why is Dirty COW considered dangerous despite being a kernel vulnerability?
10. How would you modify a program to be safe from race conditions when multiple threads access shared data?

---

## Upcoming Events

- **Week 7 (Sep 12)**: No in-person lecture as instructor will attend an overseas conference. Lecture recording will be uploaded to MyUni.
- **Week 8 Guest Lecture**: "Static analysis vs Artificial Intelligence for Secure code review" by Dr. Roland Croft (content appears in exam).
- **RangeForce & Group Project Drop-in Sessions**: Next week, Sept 8-9, Room 4.63 (1-4pm).

> "Make sure you pay attention to the guest lecture as its content will appear in the final exam."