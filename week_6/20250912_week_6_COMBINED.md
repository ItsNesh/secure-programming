<!-- 
Combined Study Guide
Generated by LectureQ
Date: 2025-09-12 15:20:10
Week/Module: Week 6
Files Combined: 2
Content Type: Mixed
-->

# Week 6 - Complete Study Guide

> **Auto-generated combined study guide**  
> Generated from 2 individual notes files  
> Date: September 12, 2025

## ðŸ“š Table of Contents

1. [Comprehensive Study Notes: Week 6 - Concurrency in Distributed Systems](#comprehensive-study-notes-week-6---concurrency-in-distributed-systems)
2. [Week 6: Lecture 6 - Concurrency Issues & Race Conditions](#week-6-lecture-6---concurrency-issues-&-race-conditions)


---

# Comprehensive Study Notes: Week 6 - Concurrency in Distributed Systems

<think>
Okay, let me approach this systematically. The user is requesting comprehensive study notes based on a textbook chapter about concurrency in distributed systems. They've provided very specific formatting requirements and content expectations.

First, I need to analyze the source material carefully. The slides cover several key aspects of concurrency:
- Introduction with Lamport's quote
- Concurrency problems (TOCTTOU attacks)
- Card fraud case study as example
- Locking mechanisms vs callback systems
- Transaction ordering issues
- Deadlock examples like dining philosophers
- ACID properties and convergence concept
- Secure time challenges

Hmm, the user emphasized "ALL content" so I must include every detail from all slides. The challenge will be organizing this dense material without missing any points while making it study-friendly.

I notice several critical concepts that need thorough explanation:
1) TOCTTOU attacks (with Unix mkdir example)
2) Card fraud processing hierarchy (floor limits, offline/online verification)
3) Publish-register-notify model
4) ACID vs convergence debate
5) NTP vulnerabilities case studies

For the study questions section, I'll create 15-20 that test both factual recall and conceptual understanding. Questions should cover:
- Definitions of key terms (TOCTTOU, ACID)
- Case study analysis (Diginotar hack consequences)
- Comparative thinking (centralized vs distributed state propagation)

The formatting requirements are strict: hierarchical headers, bolded key terms, tables for comparisons. I'll need to create a table comparing TOCTTOU examples versus prevention methods.

*checking slide 3 again*
Ah! The card fraud case has multiple layers - must include the floor limit concept and how different transaction sizes get verified at different levels. Also that Diginotar incident is crucial for showing centralization risks.

For secure time section, I should highlight:
- Cinderella attack definition
- Why Google avoids absolute time in certs
- NTP vulnerabilities (Netgear/D-Link examples)

*noting the 2016 NTP amplification attacks*
Must include that detail since it's a concrete security failure example.

The ACID vs convergence part is tricky. Need to explain why "convergence" might be sufficient when full ACID properties are too costly, using the passport example from slide 7 as contrast.

*checking for all examples*
Wait - I almost missed the Aadhar biometric ID case study in slide 5 about privacy concerns with audit trails. Must include that under credential types distinction.

For structure planning:
- Start with core definition of concurrency
- Then systematically go through each subsection (TOCTTOU, locking etc)
- Use tables where comparisons exist (like transaction verification levels)
- End with comprehensive summary and questions

*verifying slide count*
9 slides total - need to cover all 9 without missing any content points. The "non-convergent state" section on slide 7 is particularly dense with ACID properties.

For the study questions, I'll make sure they:
1) Test basic definitions (Q: What does TOCTTOU stand for?)
2) Require application of concepts (Q: How would you prevent a race condition in card authorization?)
3) Analyze case studies (Q: Why did Diginotar compromise cause such widespread disruption?)

*double-checking*
Must include all footnotes too - like the Y2K ATM example about balance checks. Those are part of "all examples" requirement.

The user is clearly preparing for an advanced exam given how they want "deep learning". So I'll avoid superficial explanations and focus on why concepts matter in real systems (e.g., explaining that Amdahl's law isn't just theory but affects actual performance gains).

*noting the banking chapter reference*
Should mention where this connects to other chapters (banking, economics) since textbook references are part of "all content".

Finally for formatting: I'll use # headers per slide sections, bold key terms like **TOCTTOU**, and create a comparison table for transaction verification levels. The summary must synthesize all concurrency challenges into one coherent framework.
</think>

*Based on Anderson's "Security Engineering" (Chapter 7)*  

---

### **1. Core Definition & Introduction**  
#### **Distributed System Fundamentals**  
- **Definition**: A system where the failure of a computer *you didnâ€™t know existed* can render your own computer unusable (*Leslie Lamport*).  
- **Key Challenge**: Concurrency issues (e.g., timing, ordering) become critical at scale.  
  > *"When you update your address book with an online service provider, the update might appear a second later on another device, or perhaps only hours later."*  

#### **Why Concurrency Matters**  
| Factor | Impact |
|--------|--------|
| **Scale** | Googleâ€™s fleet passed 1 million machines in 2011 (vs. initial 4). |
| **Device Complexity** | Luxury cars contain dozens/hundreds of processors; modern CPUs execute instructions in parallel (Spectre attack context). |
| **Virtualization** | Hypervisors like Xen turn physical CPUs into hundreds/thousands of virtual CPUs. |
| **Interaction Complexity** | A car rental booking may call credit card, insurance, and reference agencies simultaneously. |

---

### **2. Concurrency Problems & Solutions**  
#### **2.1 Time-of-Check-to-Time-of-Use (TOCTTOU) Attacks**  
##### **Concept**  
- **Definition**: An attacker exploits the time gap between *checking* a resourceâ€™s state and *using* it, causing inconsistent updates or security breaches.  
- **Prevention Cost**: Propagating updated security states is expensive (*e.g., broadcasting hot-card lists to millions of terminals*).  

##### **Examples & Case Studies**  
| Example | Mechanism | Consequence |
|---------|-----------|-------------|
| **Unix `mkdir` Vulnerability** | Privileged instruction executed in two phases; attacker renames target object mid-process. | Unauthorized directory creation with elevated privileges. |
| **IBM OS/360 File System (1960s)** | Open file â†’ check permissions â†’ read again. Attacker alters file between checks. | Bypassed access control via timing attack. |
| **Credit Card Fraud** | Merchant terminals cannot verify all cards instantly due to: <br> â€¢ Network delays in remote areas<br> â€¢ Cost of real-time bank verification.<br><br> *Solution*: Tiered offline/online validation (see below). |

##### **Card Fraud Processing Hierarchy**  
*(From Slide 3)*  
| Transaction Type | Verification Level | Rationale |
|------------------|--------------------|-----------|
| **Local/Low-Value** | Offline (floor limit) | Most payments are local; cost of online check outweighs risk. |
| **Medium Value** | Online with merchantâ€™s bank | Bank knows *local* hot cards + actively abused foreign cards. |
| **High Value** | Network-level (e.g., VISA) | Global list of compromised cards available in real-time systems. |
| **Very High Value** | Card-issuing bank direct | Ultimate verification for critical transactions. |

> ðŸ’¡ **Key Insight**: *Centralized revocation is expensive* â†’ Diginotar hack (2011) showed global compromise disrupted services when 16M certificates were revoked daily.

---

#### **2.2 Locking vs. Callback Mechanisms**  
##### **Locking for Consistency**  
- **Purpose**: Prevent inconsistent updates by ensuring only one process accesses a resource at a time.  
- **Example**: Version control systems (e.g., Git) lock files during edits to avoid merge conflicts.  

##### **Callback Model** *(Publish-Register-Notify)*  
*(From Slide 4 & 5)*  
1. **Publisher**: Issues credentials/authorizations (*e.g., hotel pre-authorizes $500 credit card*).  
2. **Register**: Merchant registers claim with bank (notifies of future debit).  
3. **Notify**: Bank updates state; merchant receives alert if card is canceled.  

##### **Trade-offs**  
| Approach | Pros | Cons |
|----------|------|------|
| **Locking** | Simple, guarantees consistency at cost of performance. | Risk of deadlocks (see Section 7.2.4). |
| **Callback** | Scalable; avoids constant state propagation. | Privacy concerns (*e.g., government tracking passport use*); issuer may refuse service. |

##### **Credential Types & Obligations**  
| Credential Type | Example | State Change? | Order Sensitivity |
|-----------------|---------|---------------|-------------------|
| **Obligation-Based** (Issuer liable) | Credit card pre-authorize | Yes (*e.g., $500 claim*) | Critical: Wrong order â†’ overdrafts. |
| **Stateless** | Passport stamping | No (*only creation/expiry matter*) | Not sensitive to order. |

> âš ï¸ **Aadhar ID Controversy**: Mandatory biometric checks create audit trails of all transactions (privacy violation risk).

---

#### **2.3 Order of Updates & Transaction Processing**  
##### **Critical Issue: Sequence Dependency**  
- **Bank Account Example**: $500,000 credit vs. $400,000 debit â†’ *order determines balance*.  
  - Traditional batch processing (overnight credits then debits) avoided sequence issues but caused delays.  
  - **Real-Time Gross Settlement (RTGS)**: Processes transactions in arrival order (*e.g., many countries adopted RTGS*).  

##### **Challenges with RTGS**  
1. Hybrid systems still use overnight batches for retail customers â†’ *inconsistent state*.  
2. Outcome depends on network/human timing â†’ *critical during large payments between banks*.  
3. **Credit Cards**: Use hybrid model (*real-time credit limits, batch settlement*).  

##### **Blockchain Misconception**  
- **Claimed Benefit**: Solves inconsistent updates via append-only ledger (e.g., supply chain management).  
- **Reality Check**:  
  - Proof-of-work blockchains are energy-intensive â†’ *unsuitable for most apps*.  
  - Off-chain mechanisms mimic traditional batch processing (*disconnected proposals reconciled later*).  

> âœ… **Conclusion**: *"No magic solution exists short of a few very competent large banks."*

---

#### **2.4 Deadlock**  
##### **Dining Philosophers Problem** (Edsger Dijkstra)  
- **Scenario**: 5 philosophers share chopsticks; each needs two to eat â†’ all pick up right chopstick, deadlock occurs.  
- **Real-World Parallel**: Systems waiting for resources locked by others (*e.g., database transactions*).  

##### **Complexity in Distributed Systems**  
| Factor | Impact |
|--------|--------|
| Multiple lock hierarchies across systems | Harder to detect/resolve deadlocks. |
| Failures causing unreliable locks | Deadlock may persist indefinitely. |
| Bureaucratic "Catch-22" (e.g., *Battle of the Forms*) | Manual workarounds fail in software â†’ system halts. |

> ðŸ’¡ **Business Example**:  
> - Company A sends order with terms X; Company B accepts with terms Y.  
> - Electronic trading favors firm that forces opponent to use its website â†’ *terms imposed via technical control*.

---

#### **2.5 Non-Convergent State & ACID vs. Convergence**  
##### **ACID Properties** (Traditional Transaction Model)  
| Property | Definition | Example |
|----------|------------|---------|
| **Atomicity** | "Do it all or nothing" â†’ no partial updates. | Bank transfer: $100 debited *only if* credited to recipient. |
| **Consistency** | Preserves invariants (e.g., balance = credits - debits). | Sum of all transactions must equal zero per account. |
| **Isolation** | Transactions appear sequential (*serializable*). | Concurrent deposits donâ€™t interfere with each other. |
| **Durability** | Updates survive failures once committed. | Transaction logged to disk; not lost on crash. |

##### **Why ACID is Overkill?**  
- **ACID Failures**: Vulnerable to obscure attacks (e.g., clock errors in Kerberos).  
- **Convergence Alternative**: *System eventually reaches consistent state if transactions taper off*.  
  - Achieved via timestamps/version numbers (*e.g., append-only logs* instead of overwrites*).  

##### **Real-Life Challenges**  
| Issue | Example |
|-------|---------|
| Inconsistent data formats | National banks have different mandatory fields in transaction records â†’ payment gateways guess incorrectly. |
| Unexplained deficits/surpluses | "Entropy" battle for security managers (e.g., Y2K ATM balance checks failed). |
| **Durability vs. Recoverability Tension** | Banks freeze compromised accounts to reverse payments, but criminals move funds across jurisdictions with slow reversal policies (*e.g., phishing victims*). |

---

#### **2.6 Secure Time Provisioning**  
##### **Critical Vulnerabilities**  
- **Cinderella Attack**: Attacker advances system clock â†’ security-critical software (e.g., firewall) "turns to pumpkin" and disables itself.  
- **IoT Risks**: Safety-critical devices using untrusted time sources could cause large-scale denial-of-service attacks.  

##### **Time Solutions & Flaws**  
| Approach | Mechanism | Risk |
|----------|-----------|------|
| **GPS/Radio Clocks** | Smartphones use GPS; IoT uses radio clocks. | Easily jammed (e.g., truck driver passing by). |
| **Lamport Time** | Logical ordering (*event A before B*), not absolute time. | Google avoids absolute time in certs â†’ uses serial number ranges + revocation. |
| **NTP (Network Time Protocol)** | Clock voting, server authentication. | â€¢ *Netgear/D-Link*: Hardcoded to UW-Madison NTP server â†’ $375k/year cost.<br>â€¢ *2016 NTP amplification attacks*: Servers used as DDoS vectors â†’ ISPs blocked NTP traffic. |

---

### **3. Fault Tolerance & Failure Recovery**  
*(Briefly covered in Slide 9; full context beyond concurrency)*  

#### **Key Insight**  
- **Security Engineering Priority**: Availability > Integrity > Confidentiality (*actual business spend*).  
  - *Example*: Banks invest more in redundant sites/networks than encryption or code reviews.  

#### **Fault Tolerance Interactions with Security**  
| Factor | Impact |
|--------|--------|
| Failure model (e.g., Byzantine faults) | Malicious attacks on redundancy mechanisms. |
| Resilience location | Redundancy must be distributed to avoid single point of failure. |
| DDoS defense | Requires availability-focused design (*core security engineer task*). |

---

### **4. Comprehensive Summary**  
#### **Concurrency Challenges at Scale**  
1. **State Propagation Cost**: Centralized revocation (e.g., hot-card lists) is expensive â†’ *tiered verification needed*.  
2. **Order Sensitivity**: Critical for financial systems (*credit/debit order*), irrelevant for stateless credentials (*passports*).  
3. **Deadlocks**: Common in distributed locks; "Catch-22" bureaucracy worsens with automation.  
4. **ACID vs. Convergence**: ACID is ideal but costly â†’ convergence suffices when updates are append-only (e.g., logs).  
5. **Time as a Security Vector**: Clock errors enable attacks (*Cinderella*); NTP has inherent vulnerabilities.  

#### **Case Study Synthesis: Diginotar Hack**  
- **Cause**: Iranian hackers compromised Dutch CA â†’ issued fake certs for Gmail of activists.  
- **Failure Points**:  
  - Delayed detection (10 days between certificate misuse and audit call).  
  - Centralized revocation system failure â†’ Chrome/Mozilla removed all Diginotar certs â†’ *Dutch public services failed*.  
- **Lesson**: *"Centralization cuts costs but amplifies disruption."*  

---

### **5. Study Questions** *(Exam Focus)*  
1. Define TOCTTOU and explain how the Unix `mkdir` vulnerability exploits it.  
2. Why canâ€™t merchant terminals verify all credit cards instantly? Describe the tiered verification system.  
3. Contrast *lock-based concurrency control* with *callback mechanisms*. Give a security trade-off for each.  
4. Explain why ACID properties are often overkill in distributed systems, and how "convergence" solves this.  
5. How does real-time gross settlement (RTGS) differ from traditional batch processing? What is its main downside?  
6. Describe the *dining philosophers* deadlock scenario and map it to a modern distributed system example.  
7. Why did Google avoid using absolute time in certificates? What alternative mechanism do they use?  
8. Analyze the Diginotar hack: How did centralization contribute to systemic failure?  
9. Explain why credit card pre-authorizations require *publish-register-notify* but passport stamps donâ€™t.  
10. Why is "order of updates" irrelevant for passports but critical for bank accounts? Provide examples.  
11. What are the two main flaws in using NTP for secure time, and how did Netgear/D-Link exemplify them?  
12. How does Amdahlâ€™s Law limit parallelization gains (show calculation)? Why is this relevant to concurrency security?  
13. Describe a *Cinderella attack* on firewalls. What IoT devices are most vulnerable?  
14. Explain the "battle of the forms" in e-commerce and why it leads to liability games.  
15. How does Aadhar biometric ID illustrate privacy concerns with stateful credentials?  
16. Why is durability a tension point for banks during fraud recovery (e.g., phishing)?  
17. What makes blockchain *unsuitable* as a general solution for inconsistent updates in distributed systems?  
18. Contrast the traditional bank transaction model (batch credits/debits) vs. modern RTGS on sequence sensitivity.  
19. How does "entropy" manifest in security management, and what is an example from the text?  
20. Why do banks spend more on availability than encryption? Link to business priorities.

---

> **Key Takeaway for Exams**: Concurrency isnâ€™t just a performance issueâ€”itâ€™s *security-critical*. Every layer (hardware â†’ application) must handle timing, ordering, and state consistency. Centralization reduces cost but increases systemic risk (*Diginotar*), while convergence offers pragmatic trade-offs where ACID is impractical.


---

# Week 6: Lecture 6 - Concurrency Issues & Race Conditions

<think>
I need to create comprehensive lecture notes for a student who missed class on Week 6, Lecture 6 about concurrency issues and race conditions. I'll synthesize all information from both the slides and transcript into natural, flowing educational notes.

Let me first outline what needs to be covered based on the provided materials:

1. **Memory Vulnerability Mitigations** (from Slide 4-10)
   - Non-executable pages
   - Return-to-libc attacks
   - Return-oriented programming (ROP)
   - Stack canaries
   - ASLR

2. **Concurrency Issues & Race Conditions**
   - Definition and examples
   - Bank withdrawal example
   - Counter incrementing example in C, Python threading, and multiprocessing
   - Global Interpreter Lock (GIL) in Python
   - Mitigations: locks, mutexes, semaphores
   - Deadlock

3. **Time-of-Check to Time-of-Use (TOCTTOU)**
   - Definition
   - Vulnerability example with file permissions
   - Attack sequence using symbolic links
   - Countermeasures

4. **Dirty COW Vulnerability**
   - Explanation of Copy-on-Write (COW)
   - How Dirty COW exploits COW mechanism
   - Exploitation steps and code examples
   - Impact on Linux systems

5. **Upcoming Events & Announcements** (from Slide 2,3,51)

Now I'll create the notes following all requirements:

- Start with clear H1 title
- Include "Overview" section immediately after title
- Use hierarchical headers for organization
- Create a summary at the end
- Format instructor insights as specified
- Synthesize slide content and transcript naturally
- Rephrase technical concepts clearly
- Include ALL examples, calculations, and key points

Let me begin drafting:


### Overview
This lecture covers concurrency issues in software systems, focusing on race conditions as a critical vulnerability class. We'll explore how concurrent execution of multiple processes/threads can lead to unexpected behavior when shared resources are accessed without proper synchronization. The lecture begins with a recap of memory vulnerability mitigations from the previous week before diving into:
- Definition and examples of race conditions
- Concurrency vulnerabilities in real-world scenarios (banking, file operations)
- Mitigation strategies including locks, mutexes, and semaphores
- Time-of-check to time-of-use (TOCTOU) vulnerabilities
- The Dirty COW vulnerability as a famous example of race condition exploitation

---

### Memory Vulnerability Recap: Key Mitigations

#### Non-Executable Pages (W^X)
The concept of **non-executable pages** prevents attackers from executing code they've injected into memory regions that are meant to be writable. This is implemented through hardware features:

> "Most programs don't need memory that is both written to and executed, so we make portions of memory either executable or writable but not both."

This approach creates a fundamental security boundary:
- **Stack, heap, and static data**: Writable but *not* executable
- **Code regions**: Executable but *not* writable

The implementation relies on page table entries having separate "writable" and "executable" bits. This is also known as:
- W^X (Write XOR Execute)
- DEP (Data Execution Prevention, Windows terminology)
- No-execute bit (the name of the hardware feature)

This mitigation prevents classic buffer overflow attacks where attackers inject shellcode into memory and redirect execution to it.

#### Bypassing Non-Executable Pages
Despite this protection, sophisticated attacks can still bypass non-executable pages:

##### Return-to-libc Attack
Instead of injecting malicious code, attackers use existing functions in the program's address space:
1. Overwrite return addresses with pointers to system calls (e.g., `system()`)
2. Pass arguments for these calls on the stack

This allows execution of arbitrary commands without needing executable memory.

> "Return-to-libc is a technique where you replace the return instruction pointer with an address that points to a library function like 'system()'."

##### Return-Oriented Programming (ROP)
A more advanced technique:
1. Attackers chain together small code snippets ("gadgets") from existing program memory
2. Each gadget ends with a `ret` instruction, allowing control flow redirection

> "In ROP, you don't need to inject your own malicious code; instead, you combine different gadgets that are already present in the executable."

#### Stack Canaries
Stack canaries add an extra layer of protection against stack-based buffer overflows:

> "A random value (canary) is placed between the buffer and control data on the stack. If this value gets overwritten during a buffer overflow attack, the program crashes before execution continues with corrupted control flow."

The implementation involves:
1. Loading a canary value from memory into register
2. Saving it to the stack just before the return address
3. Verifying its integrity when returning from a function

> "Because the write starts at 'name', the attacker has to overwrite the canary before the RIP or SFP!"

Note: On 32-bit systems, the canary value can be guessed through brute force attacks.

#### Address Space Layout Randomization (ASLR)
ASLR randomizes memory layout to make exploitation harder:
- Code segments
- Data segments
- Heap and stack locations

> "ASLR makes it difficult for attackers to predict where specific functions or data reside in memory."

The randomness is limited by the system architecture:
- 16-bit randomization on 32-bit systems (â‰ˆ 65,000 possible addresses)
- Larger randomization space on 64-bit systems

#### Limitations of Memory Mitigations
Despite these protections, vulnerabilities persist due to:

> "String format vulnerability can leak values or relative addresses. Brute-force guessing is also still a viable attack vector (though harder on 64-bit systems)."

---

### Concurrency Issues & Race Conditions

#### What Is a Race Condition?
A race condition occurs when **multiple processes access and manipulate the same data concurrently**, with outcomes depending on execution order:

> "The outcome of execution depends on a particular order. If a privileged program has a race condition, attackers may be able to affect its output by influencing uncontrollable events."

#### Real-World Example: Bank Withdrawal
Imagine two people sharing an account and attempting simultaneous withdrawals:
1. Both check balance ($100)
2. Both attempt to withdraw $100
3. Result: Account shows -$100 (withdrawn twice)

This is a classic race condition where the order of operations affects the outcome.

#### Code Example: Counter Incrementing

##### C Implementation
```c
int counter = 0;
void *increment_counter(void *arg) {
    for (int i = 0; i < 100000; i++)
        counter++; // Critical section
}
```

> "The final value will be less than expected (200,000), typically between 100,000 and 200,000."

**Why?**
- `counter++` is *not* atomicâ€”it's broken into suboperations:
  1. Read current value
  2. Increment the value
  3. Write back to memory

When two threads execute these steps simultaneously, they can both read the same initial value before either writes back.

##### Python Threading Example (GIL)
```python
counter = 0
def increment_counter():
    for _ in range(100000):
        counter += 1
```

> "Python's Global Interpreter Lock (GIL) prevents race conditions with threads because it ensures only one thread executes at a time."

**Key Insight**: The GIL makes Python safe from threading race conditions but limits parallelism.

##### Python Multiprocessing Example
```python
from multiprocessing import Process, Value
counter = Value('i', 0)
def increment_counter(shared_counter):
    for _ in range(100000):
        shared_counter.value += 1
```

> "Python processes don't share memory like threads do. The GIL doesn't apply to multiprocessing, so race conditions occur."

**Why?** Processes have separate address spaces and require explicit synchronization.

#### Mitigating Race Conditions

##### Locks & Semaphores
The primary solution is using **mutual exclusion mechanisms**:
- **Lock**: Simplest form; only one thread can access a resource at a time
- **Semaphore**: More flexible, allows multiple threads to access a resource up to a limit

> "Semaphores provide a way to control access to shared resources by maintaining a count of available permits."

##### C Implementation with Semaphores
```c
sem_t semaphore;
void *increment_counter_with_semaphore(void *arg) {
    for (int i = 0; i < 100000; i++) {
        sem_wait(&semaphore); // Acquire lock
        counter++;
        sem_post(&semaphore); // Release lock
    }
}
```

> "Using a semaphore ensures the critical section is executed atomically, preventing race conditions."

**Trade-off**: Synchronization mechanisms add overhead and can slow down applications.

#### Deadlock: A Risk of Locking Mechanisms

##### What Is a Deadlock?
A deadlock occurs when **two or more processes are waiting for each other to release resources**, causing all to be blocked indefinitely:

> "Deadlocks happen when two threads try to acquire locks in opposite orders."

##### Example Scenario
```c
// Thread 1: Withdraw from Account A, then transfer to B
sem_wait(&semA);
// ... operations on account A ...
sem_wait(&semB); // Waits if thread 2 has semB

// Thread 2: Withdraw from Account B, then transfer to A
sem_wait(&semB);
// ... operations on account B ...
sem_wait(&semA); // Waits if thread 1 has semA
```

> "If both threads acquire their first lock but wait for the second, neither can proceed."

**Key Insight**: Deadlocks are a critical risk when using multiple locks in concurrent systems.

---

### Time-of-Check to Time-of-Use (TOCTOU) Vulnerability

#### What Is TOCTOU?
A vulnerability where **a check is performed before an operation**, but the resource changes between these two steps:

> "The time gap between checking a condition and actually using the resource creates an opportunity for attackers."

This often occurs in privileged programs that perform security checks.

#### File Permission Example
Consider a setuid program (runs with elevated privileges) that:
1. Checks if user has write permission to `/tmp/X`
2. Opens file for writing

> "The check uses real UID, but the open operation uses effective UID (root), allowing attackers to exploit this gap."

##### Attack Sequence Using Symbolic Links
Attackers use a race condition to manipulate files between checks and operations:

1. **Attacker creates symbolic link** from `/tmp/X` â†’ `/etc/passwd`
2. **Vulnerable program checks permissions** on `/tmp/X` (seems safe)
3. **Before opening**, attacker changes the symlink again
4. **Program opens file** as root, writing to `/etc/passwd`

> "This is a classic TOCTOU vulnerability where attackers exploit the time gap between permission check and file access."

##### Defense Strategies Against TOCTOU
1. **Atomic operations**: Make checks and uses atomic (no time gap)
2. **Repeated checks**: Verify resource state multiple times
3. **Sticky symlink protection**: Prevent symbolic links in world-writable directories
4. **Principle of Least Privilege**: Run programs with minimal necessary privileges

> "The Principle of Least Privilege states that a program should not use more privilege than needed for its task."

**Key Insight from Transcript**:
> "If you're running as root unnecessarily, you're giving attackers an opportunity to escalate their privileges. Always run with the minimum required permissions."

---

### Dirty COW Vulnerability

#### What Is Dirty COW?
A famous race condition vulnerability in Linux kernel's **Copy-on-Write (COW)** mechanism:

> "Dirty COW is a vulnerability that exploits how Copy-on-Write works, allowing attackers to modify read-only files like /etc/passwd."

**History**: Existed since 2007 but discovered and exploited in 2016. Affected all Linux-based systems including Android.

#### How Copy-on-Write Works
COW is an optimization technique:
1. When a child process is created via `fork()`, it shares memory with parent
2. If both processes only read, they share the same physical memory
3. When one tries to write, OS creates a new copy (dirty page)

> "Copy-on-Write allows multiple processes to share memory until one needs to modify it."

##### MAP_SHARED vs. MAP_PRIVATE
| Type | Behavior |
|------|----------|
| `MAP_SHARED` | Changes visible across all processes sharing the memory |
| `MAP_PRIVATE` | Changes are private to the process; triggers COW when writing |

#### Exploiting Dirty COW

##### Core Mechanism
The vulnerability exploits three non-atomic steps:
1. Make a copy of mapped memory (A)
2. Update page table to point to new memory (B)
3. Write to memory (C)

> "If we discard the private copy between B and C, writing affects the original file."

##### Memory Advice (`madvise`)
The `madvise()` system call with `MADV_DONOTNEED` tells kernel a memory region is no longer needed:
```c
madvise(addr, length, MADV_DONOTNEED);
```

> "This causes the page table to point back to original memory before writing."

##### Attack Sequence (Simplified)
1. Map `/etc/passwd` as read-only with `MAP_PRIVATE`
2. Create two threads:
   - **Write thread**: Replace user entry in mapped memory
   - **madvise thread**: Discard private copy *before* write completes
3. If timing is right, the write affects original file

> "The attacker's goal: Change 'testcow:x:1001' to 'testcow:x:0000', making them root."

##### Resulting File Entry
```
testcow:*:0000:testcow:/root:/bin/bash
```

> "This entry gives the user UID 0 (root), allowing full system access."

**Key Insight from Transcript**:
> "Dirty COW is a race condition vulnerability that exploits how Copy-on-Write works. It's particularly dangerous because it can be used to gain root privileges on any Linux-based system."

---

### Summary & Key Takeaways

#### Core Concepts
1. **Race conditions** occur when concurrent processes access shared resources without proper synchronization.
2. **Memory mitigations** (non-executable pages, stack canaries, ASLR) are important but not foolproof.
3. **TOCTOU vulnerabilities** exploit the time gap between checking and using a resource.
4. **Dirty COW** is a famous example of race condition exploitation in Linux kernel.

#### Mitigation Strategies
| Vulnerability | Solution |
|---------------|----------|
| General Race Conditions | Locks, mutexes, semaphores |
| TOCTOU | Atomic operations, repeated checks, least privilege |
| Dirty COW | Kernel patches to make COW atomic |

#### Critical Principles
> "Concurrency is hard to get right due to the random execution order of multiple threads/processes."

> "Race conditions are particularly dangerous when they occur in privileged programs that can modify sensitive files like /etc/passwd."

**Instructor Emphasis**: 
- "Race conditions can be very difficult to detect because their occurrence depends on timing."
- "The best way to test for race conditions is to run your application multiple times with different execution orders."

#### Study Questions
1. Why does `counter++` in C lead to a race condition but not in Python threading?
2. How does the Global Interpreter Lock (GIL) prevent race conditions in Python threads?
3. What's the difference between `MAP_SHARED` and `MAP_PRIVATE` memory mapping?
4. Explain how Dirty COW exploits Copy-on-Write.
5. Why is ASLR less effective against 64-bit systems than 32-bit systems?
6. How does a stack canary work, and why might it be bypassed in 32-bit systems?
7. What's the principle of least privilege, and how does it help prevent TOCTOU vulnerabilities?
8. Describe an attack sequence for TOCTOU using symbolic links.
9. Why is Dirty COW considered dangerous despite being a kernel vulnerability?
10. How would you modify a program to be safe from race conditions when multiple threads access shared data?

#### Upcoming Events
- **Week 7**: No in-person lecture (Sep 12) - Lecture recording will be available on MyUni.
- **Week 8 Guest Lecture** by Dr. Roland Croft: "Static analysis vs Artificial Intelligence for Secure code review" (content appears in exam).
- **RangeForce & Group Project Drop-in Sessions**: Next week, Sept 8-9, Room 4.63 (1-4pm).

---

This comprehensive set of notes covers all key concepts from the slides and transcript, synthesizing them into clear educational material that a student could use to understand everything they missed in class.
</think>

# Week 6: Lecture 6 - Concurrency Issues & Race Conditions

### Overview
This lecture explores concurrency issues in software systems with a focus on race conditions as a critical vulnerability class. We begin by reviewing memory vulnerability mitigations from the previous week before diving into:
- The definition and real-world examples of race conditions
- How concurrent execution leads to unexpected behavior when shared resources are accessed without proper synchronization
- Mitigation strategies including locks, mutexes, and semaphores
- Time-of-check to time-of-use (TOCTOU) vulnerabilities
- The Dirty COW vulnerability as a famous example of race condition exploitation

---

### Memory Vulnerability Recap: Key Mitigations

#### Non-Executable Pages (W^X)
The concept of **non-executable pages** prevents attackers from executing injected code by enforcing that memory regions are either executable or writable, but not both:

> "Most programs don't need memory that is both written to and executed, so we make portions of memory either executable or writable but not both."

This hardware-enforced protection creates critical security boundaries:
- **Stack, heap, and static data**: Writable but *not* executable
- **Code regions**: Executable but *not* writable

Implemented through page table entries with separate "writable" and "executable" bits. This is also known as:
- **W^X** (Write XOR Execute)
- **DEP** (Data Execution Prevention, Windows terminology)
- **No-execute bit** (the name of the hardware feature itself)

This mitigates classic buffer overflow attacks where attackers inject shellcode into memory and redirect execution to it.

#### Bypassing Non-Executable Pages

##### Return-to-libc Attack
Attackers use existing functions in the program's address space instead of injecting malicious code:
1. Overwrite return addresses with pointers to system calls (e.g., `system()`)
2. Pass arguments for these calls on the stack

> "Return-to-libc is a technique where you replace the return instruction pointer with an address that points to a library function like 'system()', allowing execution of arbitrary commands without needing executable memory."

##### Return-Oriented Programming (ROP)
A more advanced technique:
1. Attackers chain together small code snippets ("gadgets") from existing program memory
2. Each gadget ends with a `ret` instruction, allowing control flow redirection

> "In ROP, you don't need to inject your own malicious code; instead, you combine different gadgets that are already present in the executable."

#### Stack Canaries
Stack canaries add an extra layer of protection against stack-based buffer overflows:

> "A random value (canary) is placed between the buffer and control data on the stack. If this value gets overwritten during a buffer overflow attack, the program crashes before execution continues with corrupted control flow."

The implementation involves:
1. Loading a canary value from memory into register
2. Saving it to the stack just before the return address
3. Verifying its integrity when returning from a function

> "Because the write starts at 'name', the attacker has to overwrite the canary before the RIP or SFP!"

Note: On 32-bit systems, the canary value can be guessed through brute force attacks.

#### Address Space Layout Randomization (ASLR)
ASLR randomizes memory layout to make exploitation harder:
- Code segments
- Data segments
- Heap and stack locations

> "ASLR makes it difficult for attackers to predict where specific functions or data reside in memory."

The randomness is limited by system architecture:
- **32-bit systems**: â‰ˆ 16-bit randomization (â‰ˆ 65,000 possible addresses)
- **64-bit systems**: Larger randomization space

#### Limitations of Memory Mitigations
Despite these protections, vulnerabilities persist due to:

> "String format vulnerability can leak values or relative addresses. Brute-force guessing is also still a viable attack vector (though harder on 64-bit systems)."

---

### Concurrency Issues & Race Conditions

#### What Is a Race Condition?
A race condition occurs when **multiple processes access and manipulate the same data concurrently**, with outcomes depending on execution order:

> "The outcome of execution depends on a particular order. If a privileged program has a race condition, attackers may be able to affect its output by influencing uncontrollable events."

#### Real-World Example: Bank Withdrawal
Imagine two people sharing an account and attempting simultaneous withdrawals:
1. Both check balance ($100)
2. Both attempt to withdraw $100
3. Result: Account shows -$100 (withdrawn twice)

This is a classic race condition where the order of operations affects the outcome.

#### Code Example: Counter Incrementing

##### C Implementation (Vulnerable)
```c
int counter = 0;
void *increment_counter(void *arg) {
    for (int i = 0; i < 100000; i++)
        counter++; // Critical section
}
```

> "The final value will be less than expected (200,000), typically between 100,000 and 200,000."

**Why?**
- `counter++` is *not* atomicâ€”it's broken into suboperations:
  1. Read current value
  2. Increment the value
  3. Write back to memory

When two threads execute these steps simultaneously, they can both read the same initial value before either writes back.

##### Python Threading Example (GIL)
```python
counter = 0
def increment_counter():
    for _ in range(100000):
        counter += 1
```

> "Python's Global Interpreter Lock (GIL) prevents race conditions with threads because it ensures only one thread executes at a time."

**Key Insight from Transcript**:  
> "The GIL is essentially there to prevent multiple threads accessing the same instance of the program running at the same time. As a result, this mechanism will prevent race condition from happening when using multi-threading in Python."

##### Python Multiprocessing Example (Vulnerable)
```python
from multiprocessing import Process, Value
counter = Value('i', 0)
def increment_counter(shared_counter):
    for _ in range(100000):
        shared_counter.value += 1
```

> "Python processes don't share memory like threads do. The GIL doesn't apply to multiprocessing, so race conditions occur."

**Key Insight from Transcript**:  
> "If you want to use multi-processing to speed up your application in Python, it's unlikely that you're going to get the same speedup as you expect because of how the GIL works with threads versus processes."

---

### Mitigating Race Conditions

#### Locks & Semaphores
The primary solution is using **mutual exclusion mechanisms**:
- **Lock**: Simplest form; only one thread can access a resource at a time
- **Semaphore**: More flexible, allows multiple threads to access a resource up to a limit

> "Semaphores provide a way to control access to shared resources by maintaining a count of available permits."

##### C Implementation with Semaphores (Corrected)
```c
sem_t semaphore;
void *increment_counter_with_semaphore(void *arg) {
    for (int i = 0; i < 100000; i++) {
        sem_wait(&semaphore); // Acquire lock
        counter++;
        sem_post(&semaphore); // Release lock
    }
}
```

> "Using a semaphore ensures the critical section is executed atomically, preventing race conditions."

**Trade-off**: Synchronization mechanisms add overhead and can slow down applications.

#### Deadlock: A Risk of Locking Mechanisms

##### What Is a Deadlock?
A deadlock occurs when **two or more processes are waiting for each other to release resources**, causing all to be blocked indefinitely:

> "Deadlocks happen when two threads try to acquire locks in opposite orders."

##### Example Scenario
```c
// Thread 1: Withdraw from Account A, then transfer to B
sem_wait(&semA);
// ... operations on account A ...
sem_wait(&semB); // Waits if thread 2 has semB

// Thread 2: Withdraw from Account B, then transfer to A
sem_wait(&semB);
// ... operations on account B ...
sem_wait(&semA); // Waits if thread 1 has semA
```

> "If both threads acquire their first lock but wait for the second, neither can proceed."

**Key Insight from Transcript**:  
> "Deadlock is a critical risk when using multiple locks in concurrent systems. It's like two people trying to pass through a narrow door at the same timeâ€”you get stuck waiting for each other."

---

### Time-of-Check to Time-of-Use (TOCTOU) Vulnerability

#### What Is TOCTOU?
A vulnerability where **a check is performed before an operation**, but the resource changes between these two steps:

> "The time gap between checking a condition and actually using the resource creates an opportunity for attackers."

This often occurs in privileged programs that perform security checks.

#### File Permission Example
Consider a setuid program (runs with elevated privileges) that:
1. Checks if user has write permission to `/tmp/X`
2. Opens file for writing

> "The check uses real UID, but the open operation uses effective UID (root), allowing attackers to exploit this gap."

##### Attack Sequence Using Symbolic Links
Attackers use a race condition to manipulate files between checks and operations:

1. **Attacker creates symbolic link** from `/tmp/X` â†’ `/etc/passwd`
2. **Vulnerable program checks permissions** on `/tmp/X` (seems safe)
3. **Before opening**, attacker changes the symlink again
4. **Program opens file** as root, writing to `/etc/passwd`

> "This is a classic TOCTOU vulnerability where attackers exploit the time gap between permission check and file access."

#### Defense Strategies Against TOCTOU

| Strategy | Description |
|----------|-------------|
| **Atomic operations** | Make checks and uses atomic (no time gap) |
| **Repeated checks** | Verify resource state multiple times before use |
| **Sticky symlink protection** | Prevent symbolic links in world-writable directories like `/tmp` |
| **Principle of Least Privilege** | Run programs with minimal necessary privileges |

> "The Principle of Least Privilege states that a program should not use more privilege than needed for its task."

**Key Insight from Transcript**:  
> "If you're running as root unnecessarily, you're giving attackers an opportunity to escalate their privileges. Always run with the minimum required permissions."

---

### Dirty COW Vulnerability

#### What Is Dirty COW?
A famous race condition vulnerability in Linux kernel's **Copy-on-Write (COW)** mechanism:

> "Dirty COW is a vulnerability that exploits how Copy-on-Write works, allowing attackers to modify read-only files like /etc/passwd."

**History**: Existed since 2007 but discovered and exploited in 2016. Affected all Linux-based systems including Android.

#### How Copy-on-Write Works
COW is an optimization technique:
1. When a child process is created via `fork()`, it shares memory with parent
2. If both processes only read, they share the same physical memory
3. When one tries to write, OS creates a new copy (dirty page)

> "Copy-on-Write allows multiple processes to share memory until one needs to modify it."

##### MAP_SHARED vs. MAP_PRIVATE
| Type | Behavior |
|------|----------|
| `MAP_SHARED` | Changes visible across all processes sharing the memory |
| `MAP_PRIVATE` | Changes are private to the process; triggers COW when writing |

#### Exploiting Dirty COW

##### Core Mechanism
The vulnerability exploits three non-atomic steps:
1. Make a copy of mapped memory (A)
2. Update page table to point to new memory (B)
3. Write to memory (C)

> "If we discard the private copy between B and C, writing affects the original file."

##### Memory Advice (`madvise`)
The `madvise()` system call with `MADV_DONOTNEED` tells kernel a memory region is no longer needed:
```c
madvise(addr, length, MADV_DONOTNEED);
```

> "This causes the page table to point back to original memory before writing."

##### Attack Sequence (Simplified)
1. Map `/etc/passwd` as read-only with `MAP_PRIVATE`
2. Create two threads:
   - **Write thread**: Replace user entry in mapped memory
   - **madvise thread**: Discard private copy *before* write completes
3. If timing is right, the write affects original file

> "The attacker's goal: Change 'testcow:x:1001' to 'testcow:x:0000', making them root."

##### Resulting File Entry
```
testcow:*:0000:testcow:/root:/bin/bash
```

> "This entry gives the user UID 0 (root), allowing full system access."

**Key Insight from Transcript**:  
> "Dirty COW is a race condition vulnerability that exploits how Copy-on-Write works. It's particularly dangerous because it can be used to gain root privileges on any Linux-based system."

---

### Summary & Key Takeaways

#### Core Concepts
1. **Race conditions** occur when concurrent processes access shared resources without proper synchronization.
2. **Memory mitigations** (non-executable pages, stack canaries, ASLR) are important but not foolproof.
3. **TOCTOU vulnerabilities** exploit the time gap between checking and using a resource.
4. **Dirty COW** is a famous example of race condition exploitation in Linux kernel.

#### Critical Principles
> "Concurrency is hard to get right due to the random execution order of multiple threads/processes."

> "Race conditions are particularly dangerous when they occur in privileged programs that can modify sensitive files like /etc/passwd."

**Instructor Emphasis**:  
- "The best way to test for race conditions is to run your application multiple times with different execution orders."
- "If you're not careful with concurrency, it's very easy to create vulnerabilities that are hard to detect and exploit."

#### Study Questions
1. Why does `counter++` in C lead to a race condition but not in Python threading?
2. How does the Global Interpreter Lock (GIL) prevent race conditions in Python threads?
3. What's the difference between `MAP_SHARED` and `MAP_PRIVATE` memory mapping?
4. Explain how Dirty COW exploits Copy-on-Write.
5. Why is ASLR less effective against 64-bit systems than 32-bit systems? 
6. How does a stack canary work, and why might it be bypassed in 32-bit systems?
7. What's the principle of least privilege, and how does it help prevent TOCTOU vulnerabilities?
8. Describe an attack sequence for TOCTOU using symbolic links.
9. Why is Dirty COW considered dangerous despite being a kernel vulnerability?
10. How would you modify a program to be safe from race conditions when multiple threads access shared data?

---

### Upcoming Events

- **Week 7 (Sep 12)**: No in-person lecture as instructor will attend an overseas conference. Lecture recording will be uploaded to MyUni.
- **Week 8 Guest Lecture**: "Static analysis vs Artificial Intelligence for Secure code review" by Dr. Roland Croft (content appears in exam).
- **RangeForce & Group Project Drop-in Sessions**: Next week, Sept 8-9, Room 4.63 (1-4pm).

> "Make sure you pay attention to the guest lecture as its content will appear in the final exam."

---

## ðŸ“ Study Guide Summary

This combined study guide contains all notes for **Week 6**, automatically generated from 2 individual files.

### Individual Files Included:

1. `20250912_concurrency.md`
2. `20250912_lecture_6.md`

### Usage Tips:
- Use the table of contents above to navigate quickly
- Each section is separated by horizontal rules (`---`)
- Individual files are still available for focused study
- This combined file is perfect for comprehensive review

---
*Generated by [LectureQ](https://github.com/yourusername/lectureq) - Your AI-powered study companion* ðŸ¤–
